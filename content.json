{"meta":{"title":"Sharef","subtitle":"的博客","description":"记录自己的点点滴滴而已，哈哈","author":"shijf","url":"https://blog.sharef.top","root":"/"},"pages":[{"title":"关于","date":"2020-10-14T16:56:10.381Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"about/index.html","permalink":"https://blog.sharef.top/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"","date":"2020-10-14T16:56:10.381Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"collect/index.html","permalink":"https://blog.sharef.top/collect/index.html","excerpt":"","text":"名称 链接 备注 shields小徽章 https://shields.io/ 开源中国 https://www.oschina.net/p/ok-admin 今日头条 https://www.toutiao.com/a6742646235246625283 layui年度案例 https://fly.layui.com/case/u/20099184"},{"title":"我的朋友们","date":"2020-10-14T16:56:10.381Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"friends/index.html","permalink":"https://blog.sharef.top/friends/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-14T16:56:10.381Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"mylist/index.html","permalink":"https://blog.sharef.top/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-10-14T16:56:10.381Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"blog/categories/index.html","permalink":"https://blog.sharef.top/blog/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-14T16:56:10.381Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"blog/message/index.html","permalink":"https://blog.sharef.top/blog/message/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-10-14T16:56:10.381Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"blog/tags/index.html","permalink":"https://blog.sharef.top/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记一次获取网站鉴权的实践操作","slug":"Record the practical operation of obtaining website authentication","date":"2020-07-25T13:29:02.000Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"2020/07/25/9624aeb0-afd6-11ea-9390-270475cb65f3/","link":"","permalink":"https://blog.sharef.top/2020/07/25/9624aeb0-afd6-11ea-9390-270475cb65f3/","excerpt":"记一次获取网站鉴权的实践操作 在移动端平台（就先简称PF平台）上新应用，一般会经过安全校验。所以每一个应用都会采取一些攻击策略手段来保障应用的安全稳定。一般是 xss 攻击，不过针对今天举例的系统（就先简称为BCP）他做的还是很棒的。还有就是鉴权登录，这也是主要能攻破BCP系统的关键点。 另外本文只分析破解过程，对于原理和一些名词不做过多解释。 工具 fillder（抓包工具，这个其实有没有都行，主要是爬取接口的时候，可以比较直观的。） 谷歌浏览器 PostMan（用户发送接口请求） 过程分析xss 诱导攻击BCP系统这方面考虑的比较全面，暂且不分析了。 最高鉴权获取这也是本篇文章要重点分析的部分。 起因打开PF平台上的 BCP 系统，在网络请求中发现，这样一个接口： url：jtsi/UserLogin/login method：POST 作用：用户登录，返回用户登录信息 参数字段： 字段 取值（爬取发现） 类型 是否必填 说明 deviceType D string 是 判断设备类型，貌似没啥用，不断啥就用D这个值就行 domain BCPWx string 否 用来判断是否是在 移动端 ，移动端就是 BCPWx，PC端啥也不写 timestamp 1595656277 number 是 时间戳，应该是为了标识当前调用的事件 login_type login_user string 是 用户登录类型，用 login_user 这个就行 passwd BcpWx%3c6****efbe84%3E string 是 用户的密码（为了安全，我进行了脱密处理），下文会重点分析，这个字符串，关键突破点 t 1595656277720 number 是 又来一个时间戳，不过这个是 毫秒 的，上面的 timestamp 是秒的。 返回参数： { &quot;Result&quot;: true, &quot;ReturnCode&quot;: &quot;000&quot;, &quot;ReturnMessage&quot;: { &quot;orgName&quot;: &quot;******团队&quot;, &quot;roleIds&quot;: [&quot;-1&quot;], &quot;statusMsg&quot;: &quot;登录成功&quot;, &quot;domain&quot;: &quot;&quot;, &quot;sessionId&quot;: &quot;5d1116fb-****-****-94ac-96fa19c75d30&quot;, &quot;userName&quot;: &quot;***&quot;, &quot;userId&quot;: &quot;********&quot;, &quot;orgId&quot;: &quot;**********&quot;, &quot;depts&quot;: { &quot;num&quot;: &quot;1&quot;, &quot;**********&quot;: &quot;****团队&quot; }, &quot;status&quot;: 1, &quot;token&quot;: &quot;5d1116fb-****-****-94ac-96fa19c75d30&quot; } } 从上面的请求参数开始分析： 第一步： BCP 系统的致命漏洞，也是出现在此。用户在经过 PF 平台的 Oauth2 授权后，竟然没有直接返回 token 值，而是在Oauth2 授权拿到 用户id 后，神奇的是又去请求 BCP 系统自带的登录接口（UserLogin/login），那么他就需要账号密码。 第二步： 通过第一步发现，系统在登陆前，肯定会有一次获取用户密码的请求，果不其然，在进一步抓包处理后（由于只是在手机端简单的注入了一些检测脚本，所以并没有拿到返回密码的接口，或者说在我注入脚本之前，系统就已经完成了获取密码操作，所以我一开始没有拿到这个接口），发现了一个返回用户密码的接口，这个稍后再分析。 第三步： 第二步说到：会有一个返回密码的接口，那么我们要想获取到最高权限（系统管理员）的密码，就必然得知道管理员（当然我是知道，该系统的管理员的用户id，不知道也没关系，下文会讲解怎么拿）的账号密码。 获取管理员账号1上文说到，我已经知道管理员的帐号了，因为就是系统负责人，我肯定是知道的，假如说我不知道，怎么办？ 大家知道，在公司内部一般的员工编号都是数字或者有规律的，最主要的就是可以根据自己的账号去推演，毕竟破解最多的就是穷举法。 为了更好的解释怎么获取管理员账号，我在下文会提到根据什么原理拿到管理员账号，此处假设我们知道管理员的账号了。 寻求加密突破点我们再一次回到，在移动端发现的登录接口，分析一下，此处的请求参数：passwd，为了解释简单，我们假设一个账号：12345678，他的密码（当然我是根据他的规律来生成的）是：BcpWx%3c25d55ad283aa400af464c76d713c07ad%3e，根据经验（也是常识），在接口传参数的时候我们不会有%号的出，也是我们是通过抓包拿到的字符串，肯定也会经过URL编码，那么我们反编码一下：BcpWx&lt;25d55ad283aa400af464c76d713c07ad&gt;，这个规律就有了，密码应该是加密过的，加密过后应该是：25d55ad283aa400af464c76d713c07ad，然后开发者又在密码前后分别加了 “BcpWx&lt;” 和 “&gt;”，当然如果你经验够足的话，一眼就能判断 “&gt;” 的url 编码 为 %3c， “&lt; “的编码为 %3e。那么就只剩下 25d55ad283aa400af464c76d713c07ad ，咋一看，这咋解密，无从下手，上文说到，破解、攻击等手段常用的就是穷举法（没想到第一个 BCP 就中了），最常用的就是 md5 加密，不管三七二十一，先来一波md5加密： 字符串 12345678 16位 小写 83aa400af464c76d 16位 大写 83AA400AF464C76D 32位 小写 25d55ad283aa400af464c76d713c07ad 32位 大写 25D55AD283AA400AF464C76D713C07AD 注：因为我知道我得账号是多少，所以我是拿自己的 userid，通过md5 去比对的。 到此返现了惊喜，md5 加密的 32位 小写 结果不就是，我们在接口中发现的字符串吗？其实到这里就已经攻破了，当前这是后来分析，才知道的。假设不知道的时候，我们就需要进一步发现。因为这个只是在移动端登录的接口，即使知道了，操作起来不太方便。接下来我们登录 PC 端看看会有怎样的发现。 获取管理员账号 2接上上小结的内容，假设你不知道管理员账号怎么办？PC 端登录，是用的公司统一认证平台，当登录到，总共请求了 3（有一个接口请求了两次，重复的，阿西吧） 接口：/jtsi/UserLogin/getHeadImg 、/jtsi/JTApplicationService/getApplications和/jtsi/JTApplicationService/getApplicationMenu 第一个顾名思义，请求头像的不用管，重点部分是后边两个接口，超管也顾名思义，啥都管，那么他的应用和菜单树肯定是最多的，只要根据公司的员工编号，写个批量小脚本，哪个员工的菜单树最多，他肯定就是超管了就没跑了。也有的是 admin 这种。 接口小技巧根据pc端的接口请求可以看出，BCP 系统鉴权使用的 token （移动端）和 sessionId （PC端），这也就不难理解，为啥在 jtsi/UserLogin/login 的返回结果中，为啥既有 token 还有 sessionId 了，但是他忽略了一点，也是 BCP 系统最致命的。从返回结果我们可以得出两个结论： 后台生成 token 和 sessionId 的机制一样，只是换了个名称而已 我们可以利用移动端生成的密码，去获取 token，而此处的 token也即 PC端的 sessionId 为什么要用移动端的接口去生成 token（sessionId ） 呢，上文说到，PC端登录和移动端登录时，是通过 domain 参数来判断的，加入我们不填 domain 参数，你会发现，用 md5 生成的密码对 PC 端的登录接口没用的，这也引发了我继续探寻下去的兴趣。","text":"记一次获取网站鉴权的实践操作 在移动端平台（就先简称PF平台）上新应用，一般会经过安全校验。所以每一个应用都会采取一些攻击策略手段来保障应用的安全稳定。一般是 xss 攻击，不过针对今天举例的系统（就先简称为BCP）他做的还是很棒的。还有就是鉴权登录，这也是主要能攻破BCP系统的关键点。 另外本文只分析破解过程，对于原理和一些名词不做过多解释。 工具 fillder（抓包工具，这个其实有没有都行，主要是爬取接口的时候，可以比较直观的。） 谷歌浏览器 PostMan（用户发送接口请求） 过程分析xss 诱导攻击BCP系统这方面考虑的比较全面，暂且不分析了。 最高鉴权获取这也是本篇文章要重点分析的部分。 起因打开PF平台上的 BCP 系统，在网络请求中发现，这样一个接口： url：jtsi/UserLogin/login method：POST 作用：用户登录，返回用户登录信息 参数字段： 字段 取值（爬取发现） 类型 是否必填 说明 deviceType D string 是 判断设备类型，貌似没啥用，不断啥就用D这个值就行 domain BCPWx string 否 用来判断是否是在 移动端 ，移动端就是 BCPWx，PC端啥也不写 timestamp 1595656277 number 是 时间戳，应该是为了标识当前调用的事件 login_type login_user string 是 用户登录类型，用 login_user 这个就行 passwd BcpWx%3c6****efbe84%3E string 是 用户的密码（为了安全，我进行了脱密处理），下文会重点分析，这个字符串，关键突破点 t 1595656277720 number 是 又来一个时间戳，不过这个是 毫秒 的，上面的 timestamp 是秒的。 返回参数： { &quot;Result&quot;: true, &quot;ReturnCode&quot;: &quot;000&quot;, &quot;ReturnMessage&quot;: { &quot;orgName&quot;: &quot;******团队&quot;, &quot;roleIds&quot;: [&quot;-1&quot;], &quot;statusMsg&quot;: &quot;登录成功&quot;, &quot;domain&quot;: &quot;&quot;, &quot;sessionId&quot;: &quot;5d1116fb-****-****-94ac-96fa19c75d30&quot;, &quot;userName&quot;: &quot;***&quot;, &quot;userId&quot;: &quot;********&quot;, &quot;orgId&quot;: &quot;**********&quot;, &quot;depts&quot;: { &quot;num&quot;: &quot;1&quot;, &quot;**********&quot;: &quot;****团队&quot; }, &quot;status&quot;: 1, &quot;token&quot;: &quot;5d1116fb-****-****-94ac-96fa19c75d30&quot; } } 从上面的请求参数开始分析： 第一步： BCP 系统的致命漏洞，也是出现在此。用户在经过 PF 平台的 Oauth2 授权后，竟然没有直接返回 token 值，而是在Oauth2 授权拿到 用户id 后，神奇的是又去请求 BCP 系统自带的登录接口（UserLogin/login），那么他就需要账号密码。 第二步： 通过第一步发现，系统在登陆前，肯定会有一次获取用户密码的请求，果不其然，在进一步抓包处理后（由于只是在手机端简单的注入了一些检测脚本，所以并没有拿到返回密码的接口，或者说在我注入脚本之前，系统就已经完成了获取密码操作，所以我一开始没有拿到这个接口），发现了一个返回用户密码的接口，这个稍后再分析。 第三步： 第二步说到：会有一个返回密码的接口，那么我们要想获取到最高权限（系统管理员）的密码，就必然得知道管理员（当然我是知道，该系统的管理员的用户id，不知道也没关系，下文会讲解怎么拿）的账号密码。 获取管理员账号1上文说到，我已经知道管理员的帐号了，因为就是系统负责人，我肯定是知道的，假如说我不知道，怎么办？ 大家知道，在公司内部一般的员工编号都是数字或者有规律的，最主要的就是可以根据自己的账号去推演，毕竟破解最多的就是穷举法。 为了更好的解释怎么获取管理员账号，我在下文会提到根据什么原理拿到管理员账号，此处假设我们知道管理员的账号了。 寻求加密突破点我们再一次回到，在移动端发现的登录接口，分析一下，此处的请求参数：passwd，为了解释简单，我们假设一个账号：12345678，他的密码（当然我是根据他的规律来生成的）是：BcpWx%3c25d55ad283aa400af464c76d713c07ad%3e，根据经验（也是常识），在接口传参数的时候我们不会有%号的出，也是我们是通过抓包拿到的字符串，肯定也会经过URL编码，那么我们反编码一下：BcpWx&lt;25d55ad283aa400af464c76d713c07ad&gt;，这个规律就有了，密码应该是加密过的，加密过后应该是：25d55ad283aa400af464c76d713c07ad，然后开发者又在密码前后分别加了 “BcpWx&lt;” 和 “&gt;”，当然如果你经验够足的话，一眼就能判断 “&gt;” 的url 编码 为 %3c， “&lt; “的编码为 %3e。那么就只剩下 25d55ad283aa400af464c76d713c07ad ，咋一看，这咋解密，无从下手，上文说到，破解、攻击等手段常用的就是穷举法（没想到第一个 BCP 就中了），最常用的就是 md5 加密，不管三七二十一，先来一波md5加密： 字符串 12345678 16位 小写 83aa400af464c76d 16位 大写 83AA400AF464C76D 32位 小写 25d55ad283aa400af464c76d713c07ad 32位 大写 25D55AD283AA400AF464C76D713C07AD 注：因为我知道我得账号是多少，所以我是拿自己的 userid，通过md5 去比对的。 到此返现了惊喜，md5 加密的 32位 小写 结果不就是，我们在接口中发现的字符串吗？其实到这里就已经攻破了，当前这是后来分析，才知道的。假设不知道的时候，我们就需要进一步发现。因为这个只是在移动端登录的接口，即使知道了，操作起来不太方便。接下来我们登录 PC 端看看会有怎样的发现。 获取管理员账号 2接上上小结的内容，假设你不知道管理员账号怎么办？PC 端登录，是用的公司统一认证平台，当登录到，总共请求了 3（有一个接口请求了两次，重复的，阿西吧） 接口：/jtsi/UserLogin/getHeadImg 、/jtsi/JTApplicationService/getApplications和/jtsi/JTApplicationService/getApplicationMenu 第一个顾名思义，请求头像的不用管，重点部分是后边两个接口，超管也顾名思义，啥都管，那么他的应用和菜单树肯定是最多的，只要根据公司的员工编号，写个批量小脚本，哪个员工的菜单树最多，他肯定就是超管了就没跑了。也有的是 admin 这种。 接口小技巧根据pc端的接口请求可以看出，BCP 系统鉴权使用的 token （移动端）和 sessionId （PC端），这也就不难理解，为啥在 jtsi/UserLogin/login 的返回结果中，为啥既有 token 还有 sessionId 了，但是他忽略了一点，也是 BCP 系统最致命的。从返回结果我们可以得出两个结论： 后台生成 token 和 sessionId 的机制一样，只是换了个名称而已 我们可以利用移动端生成的密码，去获取 token，而此处的 token也即 PC端的 sessionId 为什么要用移动端的接口去生成 token（sessionId ） 呢，上文说到，PC端登录和移动端登录时，是通过 domain 参数来判断的，加入我们不填 domain 参数，你会发现，用 md5 生成的密码对 PC 端的登录接口没用的，这也引发了我继续探寻下去的兴趣。 探寻PC端登录接口上一节说到，如果想用 md5 的密码来获取 token，我们怎么办呢？看一下 PC 的登录接口，在登录的一瞬间，我抓到三个接口：/jtsi/IAMService/getUserInfo 、/jtsi/UserLogin/generatorKey 和 /jtsi/UserLogin/login getUserInfo (根据统一认证平台返回的code，拿到当前用户id，其实都拿到 id 了，还进行以下两步，哎) 请求参数： { &quot;code&quot;: &quot;e829b71a*******5d803903b82&quot;, &quot;url&quot;: &quot;http://**************/jtcl/bcp-eb/initial.html&quot;, &quot;domain&quot;: &quot;&quot;, &quot;deviceType&quot;: &quot;D&quot; } 返回响应(移动端也是因为这个出现的漏洞)：{ &quot;Result&quot;: true, &quot;ReturnCode&quot;: &quot;000&quot;, &quot;ReturnMessage&quot;: { &quot;password&quot;: &quot;BcpIAMLogin&lt;069*********2f8346768&gt;&quot;, &quot;userId&quot;: &quot;********&quot; } } generatorKey（多次调用后发现，这个加密 key 居然是固定不变的，即每个人都是固定的一个值，那么我们只需要获取一次，就可以拿到该用户的密码） 请求参数： { &quot;userId&quot;: &quot;********&quot;, &quot;domain&quot;: &quot;&quot;, &quot;deviceType&quot;: &quot;D&quot; } 返回响应：{ &quot;Result&quot;: true, &quot;ReturnCode&quot;: &quot;000&quot;, &quot;ReturnMessage&quot;: { &quot;type&quot;: &quot;AES&quot;, &quot;key&quot;: &quot;8NON*******ysWpM&quot; } } login（登录接口，返回 sessionId） 请求参数： { &quot;userId&quot;: &quot;********&quot;, &quot;domain&quot;: &quot;&quot;, &quot;deviceType&quot;: &quot;D&quot;, &quot;login_type&quot;: &quot;login_user&quot;, &quot;passwd&quot;: &quot;GasFj9PbWBEgr%2FU7IDI%2B1Eg5rtbVDI9KEK38dr%2Fcg%2BOWZk***zcwa4GP1qO&quot;, // 一般有百分号的都是经俩编码的，记得解码 &quot;timestamp&quot;: 1595642745 } ​ 返回响应： { &quot;Result&quot;: true, &quot;ReturnCode&quot;: &quot;000&quot;, &quot;ReturnMessage&quot;: { &quot;orgName&quot;: &quot;****团队&quot;, &quot;roleIds&quot;: [&quot;-1&quot;], &quot;statusMsg&quot;: &quot;登录成功&quot;, &quot;domain&quot;: &quot;&quot;, &quot;sessionId&quot;: &quot;5d1116fb-****-****-94ac-96fa19c75d30&quot;, &quot;userName&quot;: &quot;***&quot;, &quot;userId&quot;: &quot;********&quot;, &quot;orgId&quot;: &quot;******0***&quot;, &quot;depts&quot;: { &quot;num&quot;: &quot;1&quot;, &quot;******0***&quot;: &quot;***团队&quot; }, &quot;status&quot;: 1, &quot;token&quot;: &quot;5d1116fb-****-****-94ac-96fa19c75d30&quot; } } 从上面三个接口可以看出，是依次递进的，先通过 getUserInfo 拿到 用户账号即 userId , 再通过 generatorKey 拿到加密密钥（后面会讲这个用处，以及好玩之处），最后通过 *login *接口，获得 sessionId 来登录系统。 思路理清后，好像还是不能获得 PC 端登录时的密码是啥，即 domain参数为空时，调用 login 接口。但是通过第二个接口，可以给我们一些惊喜，我们分析一下BCP系统的前端登录逻辑： 拿到 login.js 文件（本文只显示关键代码）： // ……部分代码 reqData.userId = userId; // 这个是 用户的id var keyAction = loginAction.generatorKey; // 获取 key 的接口的 方法 jt.ajax(keyAction, reqData, function(resData){ // 上文中提到的第二个接口即获取 key 值，就是这句代码来 执行后发出的请求 if(resData &amp;&amp; resData.type &amp;&amp; resData.key){ var encryptType = resData.type; // 拿到 key 值的加密 类型，即加密密码时，是采用哪种加密方式 var encryptKey = resData.key; // 获取加密时，需要的密钥 passwd = jt.util.encryptString(passwd, encryptKey, encryptType); // 加密代码，都是在前端加密的，这个开发者真是o((⊙﹏⊙))o.，我们可以在控制台调用这个方法，来获取方法 passwd = encodeURIComponent(passwd); // 开发者可能觉得上边的加密，还需要 编码以下 } jt.security.login(loginAction.login, userId, passwd, $scope.myCallback, reqData); // 执行登录操作 }); encryptString 方法的代码(在jt.core.min.js， 这个真心应该放在后端代码中)： // 加密代码 var encryptString=function(plaint,key,type){type=type?type.toUpperCase():type;if(&quot;AES&quot;==type){return AESEncrypt(plaint,key)}else{if(&quot;DES&quot;==type||&quot;3DES&quot;==type){return DESEncrypt(plaint,key)}else{if(&quot;RSA&quot;==type){return RSAEncrypt(plaint,key)}else{return plaint}}}}; // 解密代码，如果你不知道自己的密码，可以在控制台调用以下这个方法，O(∩_∩)O var decryptString=function(encrypted,key,type){type=type?type.toUpperCase():type;if(&quot;AES&quot;==type){return AESDecrypt(encrypted,key)}else{if(&quot;DES&quot;==type||&quot;3DES&quot;==type){return DESDecrypt(encrypted,key)}else{if(&quot;RSA&quot;==type){return RSADecrypt(encrypted,key)}else{return encrypted}}}}; 到此，我们就拿到了用户的在加密后的密码，从而也就拿到了，通过 PC 端请求接口时，即 domain为空时，获取到他的 token值，也就是 凭证，接下来只需要知道接口就可以为所欲为了，也就获取了鉴权权限。 重点来了通过在PC端登录逻辑的分析，BCP系统的用户密码就是移动端请求时参数里面的密码（BcpWx%3c6****efbe84%3E），在PC端登录时，再进行加密此密码，来登录PC端。 题外话可能超管都不知道他的密码是啥（超管登录是通过统一认证平台登录的），因为开发者和超管不是一个人，密码也是程序批量自动生成的，他想改还不知到原密码，其实这才是最好玩的。 总结熟话说，破解不是目的，目的是为了学（po）习（jie）。 本文中，没有用插图，主要是为了加载速度，已经易于传播。 如果开发BCP系统的开发者能： 多余参数不要，省带宽，降风险 加密在后端做 多一些开发经验 那么我也不会这么轻易的拿到鉴权权限。","categories":[],"tags":[]},{"title":"用 js 模拟 php __callstatic魔术方法","slug":"callStatic-1592314142869","date":"2020-06-16T13:29:02.000Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"2020/06/16/a625aad0-afd6-11ea-9390-270475cb65e3/","link":"","permalink":"https://blog.sharef.top/2020/06/16/a625aad0-afd6-11ea-9390-270475cb65e3/","excerpt":"","text":"php 中 的__callStatic()&lt;?php /** * 魔术方法:__call()和__callStatic() * __call($name, $arguments):调用类中不存在的动态方法,自动调用 * __callStatic($name, $arguments):调用类中不存在的静态方法,自动调用 * 以上二个魔术方法实现了方法的重载 */ require &#39;call_back.php&#39;; class Call_1 { //调用动态方法 public function __call($name, $arguments) { //打印出方法名和参数，参数是在数组$arguments中 // return &#39;&lt;p&gt;方法名：&#39;.$name.&#39;,参数是:(&#39;.implode(&#39;,&#39;,$arguments).&#39;)&lt;/p&gt;&#39;; //跨类调用方法 //call_user_func_array($method,$array_param); // print_r($arguments); //call_user_func_array([对象,&#39;方法名&#39;,参数数组]) return call_user_func_array([(new Call_2()),$name],$arguments); } //调用静态方法 public static function __callStatic($name, $arguments) { return call_user_func_array([&#39;Call_2&#39;,$name],$arguments); } } //动态 $obj = new Call_1(); echo $obj-&gt;hello(1,2,3);//输出6，成功调用了Call_2类中的方法 echo &#39;&lt;hr&gt;&#39;; //静态 echo $obj-&gt;add(1,100);//结果输出5050，成功调用了Call_2类中的add（）方法 js 中可以借助 proxy 来高效实现 php中的 __callStatic()方法// index.js /** * @description: 工厂函数 * @param {null} * @return: 对应的实例 */ class Factory { static make(){ const application = require(`./lib/platform/${Factory.staticName}/application`) return new application(arguments[0]) } } // 数据劫持 var P = new Proxy(Factory, { get: (target, property) =&gt; { target.staticName = property; return target.make; } }); P.wwlocal(&#39;这是一份配置&#39;); //需要导入的包 // ./lib/platform/wwlocal/application class Application { constructor(config){ console.log(&#39;我收到的&#39;+ config ); } } module.exports = Application 在 index.js 中调用 P.wwlocal(‘这是一份配置’), 可以 很方便的导入 ./lib/platform/wwlocal/application，并返回实例，这样可以： 减少代码量 调用方便 建议在nodejs高版本的使用，否则可以用Object。property来改造下这个数据劫持方法","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://blog.sharef.top/tags/php/"},{"name":"nodejs","slug":"nodejs","permalink":"https://blog.sharef.top/tags/nodejs/"}]},{"title":"用 js 模拟 php __callstatic魔术方法","slug":"php-callStatic-1592314142869","date":"2020-06-16T13:29:02.000Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"2020/06/16/9624aeb0-afd6-11ea-9390-270475cb65e3/","link":"","permalink":"https://blog.sharef.top/2020/06/16/9624aeb0-afd6-11ea-9390-270475cb65e3/","excerpt":"","text":"php 中 的__callStatic()&lt;?php /** * 魔术方法:__call()和__callStatic() * __call($name, $arguments):调用类中不存在的动态方法,自动调用 * __callStatic($name, $arguments):调用类中不存在的静态方法,自动调用 * 以上二个魔术方法实现了方法的重载 */ require &#39;call_back.php&#39;; class Call_1 { //调用动态方法 public function __call($name, $arguments) { //打印出方法名和参数，参数是在数组$arguments中 // return &#39;&lt;p&gt;方法名：&#39;.$name.&#39;,参数是:(&#39;.implode(&#39;,&#39;,$arguments).&#39;)&lt;/p&gt;&#39;; //跨类调用方法 //call_user_func_array($method,$array_param); // print_r($arguments); //call_user_func_array([对象,&#39;方法名&#39;,参数数组]) return call_user_func_array([(new Call_2()),$name],$arguments); } //调用静态方法 public static function __callStatic($name, $arguments) { return call_user_func_array([&#39;Call_2&#39;,$name],$arguments); } } //动态 $obj = new Call_1(); echo $obj-&gt;hello(1,2,3);//输出6，成功调用了Call_2类中的方法 echo &#39;&lt;hr&gt;&#39;; //静态 echo $obj-&gt;add(1,100);//结果输出5050，成功调用了Call_2类中的add（）方法 js 中可以借助 proxy 来高效实现 php中的 __callStatic()方法// index.js /** * @description: 工厂函数 * @param {null} * @return: 对应的实例 */ class Factory { static make(){ const application = require(`./lib/platform/${Factory.staticName}/application`) return new application(arguments[0]) } } // 数据劫持 var P = new Proxy(Factory, { get: (target, property) =&gt; { target.staticName = property; return target.make; } }); P.wwlocal(&#39;这是一份配置&#39;); //需要导入的包 // ./lib/platform/wwlocal/application class Application { constructor(config){ console.log(&#39;我收到的&#39;+ config ); } } module.exports = Application 在 index.js 中调用 P.wwlocal(‘这是一份配置’), 可以 很方便的导入 ./lib/platform/wwlocal/application，并返回实例，这样可以： 减少代码量 调用方便 建议在nodejs高版本的使用，否则可以用Object。property来改造下这个数据劫持方法","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://blog.sharef.top/tags/php/"},{"name":"nodejs","slug":"nodejs","permalink":"https://blog.sharef.top/tags/nodejs/"}]},{"title":"Vue原理剖析之数据代理和数据递归劫持","slug":"untitled-1592057426578","date":"2020-06-13T14:10:26.000Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"2020/06/13/d5e66740-ad7f-11ea-aa55-150e2fc8d2f7/","link":"","permalink":"https://blog.sharef.top/2020/06/13/d5e66740-ad7f-11ea-aa55-150e2fc8d2f7/","excerpt":"","text":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Vue原理&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;script&gt; let vm = new myVue({ data: { age: 12, score: { math: 99, english: 89 } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; class myVue { constructor(options) { this._options = options; this.$data = options.data; this._initData() } &lt;!-- more --&gt; _initData() { let data = this.$data let keys = Object.keys(data) // 数据代理 // 实现 vm.a 可以拿到 示例中 data的a的值 for (let index = 0; index &lt; keys.length; index++) { Object.defineProperty(this, keys[index], { enumerable: true, // 可遍历 configurable: true, // 可被改写 get: function proxyGetter() { return data[keys[index]] }, set: function proxySetter(val) { data[keys[index]] = val } }) } // 数据劫持，data 中的任意数据有变动时 进行劫持 observe(data) } } // 判断data是否是基础类型, 递归数data据劫持 function observe(data) { // 使用Object.prototype上的原生toString()方法判断数据类型 // 参考链接：https://blog.csdn.net/u012158998/article/details/86423270 // 判断 data 属性是否是 数组或者 对象类型 const type = Object.prototype.toString.call(data) if (type !== &quot;[object Array]&quot; &amp;&amp; type !== &quot;[object Object]&quot;) { // 基础类型无需遍历 return; } // 递归处理 数据劫持 new Observer(data) } /** * 4. 实现数据劫持工具方法 * @param {*} obj 要劫持的数据 * @param {*} objKey 劫持数据的类型 * @param {*} value 劫持数据的原始值 */ function defineReactive(obj, objKey, value) { // 判断下是否可以继续遍历，由内向外的遍历 observe(obj[objKey]) Object.defineProperty(obj, objKey, { enumerable: true, // 可遍历 configurable: true, // 可被改写 get: function proxyGetter() { console.log(`${objKey}取值`); return value }, set: function proxySetter(val) { console.log(`${objKey}发生了改变`); value = val } }) } // class Observer { constructor(data) { this._walk(data) } _walk(data) { let keys = Object.keys(data) for (let index = 0; index &lt; keys.length; index++) { // 针对每一层开始遍历数据并劫持 defineReactive(data, keys[index], data[keys[index]]) } } }","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.sharef.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.sharef.top/tags/vue/"}]},{"title":"彻底搞定flex (持续更新)","slug":"studyFlexdispaly","date":"2020-06-04T05:38:25.000Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"2020/06/04/074be1f0-a666-11ea-8193-9355c0848143/","link":"","permalink":"https://blog.sharef.top/2020/06/04/074be1f0-a666-11ea-8193-9355c0848143/","excerpt":"flex 布局初体验 假设我们要实现一个这样的布局，三个色块水平排版;","text":"flex 布局初体验 假设我们要实现一个这样的布局，三个色块水平排版; 一般写法&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;flex&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; *{ margin: 0; padding: 0; } ul { margin: 50px; border: 1px solid #000000; overflow: hidden; width: 300px; color: #ffffff; } li { line-height: 50px; list-style: none; height: 50px; width: 50px; background-color: blue; text-align: center; float: left; } ul li:first-child { background-color: red; } ul li:last-child{ background-color: green; } 从代码看出，我们用了浮动。而且浮动布局并不会撑起父元素的高度，我们还需要清除浮动(overflow: hidden;) 用flex布局实现*{ margin: 0; padding: 0; } ul { margin: 50px; border: 1px solid #000000; /* overflow: hidden; */ width: 300px; color: #ffffff; display: flex; } li { line-height: 50px; list-style: none; height: 50px; width: 50px; background-color: blue; text-align: center; /* float: left; */ } ul li:first-child { background-color: red; } ul li:last-child{ background-color: green; } 我们只需要告诉父元素，display: flex; 即可实现。是不是 so easy！ 基本概念 伸缩容器： 在上述的示例中，ul 即为伸缩容器 伸缩项： 伸缩容器的子元素，就是伸缩项，在上述示例中，li 为伸缩项 主轴: 在默认情况下水平方向上称为主轴，主轴的从左到右 分别为 主轴的起点、主轴的终点 侧轴：在默认情况下垂直方向上称为侧轴，侧轴的从上到下 分别称为 侧轴的起点、侧轴的终点 图示说明： 主轴方向*{ margin: 0; padding: 0; } ul { margin: 50px; border: 1px solid #000000; width: 300px; color: #ffffff; display: flex; } li { line-height: 50px; list-style: none; height: 50px; width: 50px; background-color: blue; text-align: center; } ul li:first-child { background-color: red; } ul li:last-child{ background-color: green; } 以上代码的效果： 可以看到，flex 默认的排版时从左到有的，即主轴方向是水平向右的。如果需要想要从右向左，则需要修改主轴的起点方向。 相关属性：flex-direction 属性参数： row（默认：水平从左到右）row-reverse（从右到左） 我们来试一下不同的取值: row-reverse （主轴从右到左） ul{ flex-direction: row-reverse; } column（主轴方向垂直从上到下） ul{ flex-direction: column; } column-reverse (主轴反向垂直从下到上) 注意点：只要主轴发生了变化，侧轴也会变化，永远都是十字交叉的。 主轴的对齐方式 相关属性： justify-content 相关取值效果展示：注意： 此时的 主轴方向 为默认的 row 取值 flex-start(默认) : 让伸缩项与主轴起点对齐ul { margin: 50px; border: 1px solid #000000; width: 300px; color: #ffffff; display: flex; flex-direction: row; justify-content: flex-start; // 修改不同的取值 } flex-end ：让伸缩项与主轴终点对齐 center: 伸缩项位于主轴的中点 space-between: 两端对齐 先看效果再说原理： 每两个伸缩项间的距离 = (伸缩容器的宽度 - 所有伸缩项的宽度的总和) / (伸缩项的个数 - 1) 伸缩项（个数大于2时）的排列规律是：起点、终点各一个，剩下的间距为 每两个伸缩项间的距离。5.space-around 环绕对齐 每个伸缩项的两边的距离 = (伸缩容器的宽度 - 所有伸缩项的宽度的总和) / (伸缩项的个数 * 2) 上图中，绿色小方块的距离即为：每个伸缩项的两边的距离 总结： flex-direction 告诉伸缩容器主轴的的方向 justify-content 告诉伸缩项的对齐规则 侧轴对齐方式开始之前，修改下 伸缩容器 ul 的告诉为 600px； ul { margin: 50px; border: 1px solid #000000; width: 300px; height: 600px; /*增加了此处*/ color: #ffffff; display: flex; /*默认*/ flex-direction: row; /*默认*/ } 相关属性： align-items 侧轴对齐方式ul { margin: 50px; border: 1px solid #000000; width: 300px; height: 300px; color: #ffffff; display: flex; flex-direction: row; align-items: flex-start; /*增加了此处*/ } 属性： flex-start（默认）和侧轴起点对齐 flex-end： 和侧轴终点对齐 center：和侧轴中点位置对齐 baseline 基线对齐，让所有伸缩项的基线对齐 再来个图： baseline的确定规则a) . inline-table元素的baseline是它的table第一行的baselineb). 父元素【line box】的baseline是最后一个inline box 的baseline inline-block元素的baseline确定规则 规则1：inline-block元素，如果内部有line box，则inline-block元素的baseline就是最后一个作为内容存在的元素[inline box]的baseline，而这个元素的baseline的确定就要根据它自身来定了。 规则2：inline-block元素，如果其内部没有line box或它的overflow属性不是visible，那么baseline将是这个inline-block元素的底margin边界。 为了看到更清楚： li { line-height: 50px; list-style: none; height: 50px; width: 50px; text-align: center; } ul li:nth-child(2) { background-color: blue; padding-top: 25px; /*新增的内容*/ } 可以看出，只有将第一个和第二和顶下来，才能保证三个伸缩项保持基线对齐。 stretch 拉伸对齐（等高对齐） 让所有伸缩项的高度变为侧轴的高度 ul { margin: 50px; border: 1px solid #000000; width: 300px; height: 300px; color: #ffffff; display: flex; flex-direction: row; align-items: stretch; /*修改了此处*/ } 注意：如果要使用拉伸对齐，那么伸缩项就不能设置高度，否则会失效修改代码： li { /* line-height: 50px; */ /*注释掉他*/ list-style: none; /* height: 50px; */ /*注释掉他*/ width: 50px; text-align: stre; } 总结 align-items 规定了侧轴的对齐方式 和主轴对齐属性（justify-content）相比，侧轴对齐属性没有两端对齐和环绕对齐，但是新增了其他属性 侧轴的对齐方式2（设置单独的某个伸缩项在侧轴的对齐方式）","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.sharef.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"教程","slug":"前端/教程","permalink":"https://blog.sharef.top/categories/%E5%89%8D%E7%AB%AF/%E6%95%99%E7%A8%8B/"},{"name":"flex","slug":"前端/教程/flex","permalink":"https://blog.sharef.top/categories/%E5%89%8D%E7%AB%AF/%E6%95%99%E7%A8%8B/flex/"}],"tags":[{"name":"css","slug":"css","permalink":"https://blog.sharef.top/tags/css/"}]},{"title":"如何利用 VSCode 打造一个 java 的开发环境","slug":"spring-boot-env","date":"2020-05-15T04:47:33.000Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"2020/05/15/30e42f40-9667-11ea-a46f-b77762f93269/","link":"","permalink":"https://blog.sharef.top/2020/05/15/30e42f40-9667-11ea-a46f-b77762f93269/","excerpt":"安装 Java 环境概述概念理解： J2SE 标准版 J2EE 企业版 J2ME 用于移动设备、嵌入式设备 JRE、JDK、JVM之间的区别与联系 JVM ：英文名称（Java Virtual Machine），就是我们耳熟能详的 Java 虚拟机。它只认识 xxx.class 这种类型的文件，它能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。所以说，jvm 是 Java 能够跨平台的核心，具体的下文会详细说明。 JRE ：英文名称（Java Runtime Environment），我们叫它：Java 运行时环境。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。 JDK ：英文名称（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe，java.exe，jar.exe 等。 显然，这三者的关系是：一层层的嵌套关系。JDK&gt;JRE&gt;JVM","text":"安装 Java 环境概述概念理解： J2SE 标准版 J2EE 企业版 J2ME 用于移动设备、嵌入式设备 JRE、JDK、JVM之间的区别与联系 JVM ：英文名称（Java Virtual Machine），就是我们耳熟能详的 Java 虚拟机。它只认识 xxx.class 这种类型的文件，它能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。所以说，jvm 是 Java 能够跨平台的核心，具体的下文会详细说明。 JRE ：英文名称（Java Runtime Environment），我们叫它：Java 运行时环境。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。 JDK ：英文名称（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe，java.exe，jar.exe 等。 显然，这三者的关系是：一层层的嵌套关系。JDK&gt;JRE&gt;JVM Linux 安装 Java 环境此处需要结合上一篇 《在win 10 环境下 如何打造一套适合的开发环境》，将ubuntu 设置为 主要的开发、运行环境。 官网地址：https://www.oracle.com/downloads/#category-java （2020/03/30版，可能链接会变化） 找到 Java -&gt; Java (JDK) for Developers 点击，目前地址 ：https://www.oracle.com/java/technologies/javase-downloads.html 这里采用 Linux Compressed Archive ，下载地址：https://download.oracle.com/otn-pub/java/jdk/14+36/076bab302c7b4508975440c56f6cc26a/jdk-14_linux-x64_bin.tar.gz 下载太慢，尝试使用迅雷等工具，如果链接地址有 auth 字样的参数，请删除 以下是在 linux 环境中安装, 用 $ 来注明 // 新建目录 $ sudo mkdir /url/local -p soft/java // 将软件包移动到新建的目录 $ sudo mv ./jdk-14_linux-x64_bin.tar.gz /url/local/soft/java // 移动到 java 目录下 $ cd /url/local/soft/java // 解压 $ sudo tar -zxvf jdk-14_linux-x64_bin.tar.gz // `ls` 查看发现，没有jre目录，此时需要手动安装一下 $ sudo cd jdk-14/bin &amp;&amp; ./jlink.exe --module-path jmods --add-modules java.desktop --output jre // 设置环境变量 $ sudo vim /etc/profile // 在文件末尾添加以下代码 // /etc/profile set java environment JAVA_HOME=/usr/local/soft/java/jdk-14 JRE_HOME=/usr/local/soft/java/jdk-14/jre CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin export JAVA_HOME JRE_HOME CLASS_PATH PATH // 刷新终端区域，使配置生效。 $ sudo source /etc/profile // 测试 $ java -version 打印出 java 版本信息，则说明 JDK 安装成功 注意，如果你在 wsl，可能需要重启 linux 子系统，简单除暴，重启下电脑 安装 maven 并配置 阿里源 官网地址：https://maven.apache.org/download.cgi 国内加速地址：http://mirror.bit.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz // 新建目录 $ sudo mkdir /url/local/soft/maven // 移动到新建好的目录 $ cd /url/local/soft/maven // 下载安装包 $ sudo wget http://mirror.bit.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz // 解压 $ sudo tar zvxf apache-maven-3.6.3-bin.tar.gz // 测试安装包, 如果可以打印出版本信息，则下载、解压没有问题 $ sudo cd apache-maven-3.6.3 &amp;&amp; ./bin/mvn -v // 设置环境变量 $ sudo vim /etc/profile // 在文件结尾添加以下配置信息 export MAVEN_HOME=/url/local/soft/maven/apache-maven-3.6.3 export PATH=$MAVEN_HOME/bin:$PATH // 保存并source profile $ sudo source /ect/profile // 测试环境变量 $ mvn -v 打印出 maven 版本信息，则说明 maven 安装成功注意，如果你在 wsl，可能需要重启 linux 子系统，简单除暴，重启下电脑 配置国内 阿里 镜像 源，或者是 私有库地址加速 &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 首先，编辑文件 /url/local/soft/maven/apache-maven-3.6.3/conf/settings.xml，将上述的配置信息添加到 mirrors（镜像）节点。然后，重启 vs code，即可生效。 环境信息 java 或者 jdk 安装路径 /usr/local/soft/java/jdk-14 maven 安装路径 /usr/local/soft/maven/apache-maven-3.6.3 可能每个人 安装的 路径 不太相同，除非是按着以上步骤来的，不过不要紧，可以通过which mvn 和 which java 分别来查看 当前系统安装的 maven 和 java 的路径比如我查到的路径分别为： /usr/local/soft/maven/apache-maven-3.6.3/bin/mvn /usr/local/soft/java/jdk-14/bin/java So easy, too happy ! 安装扩展包 搜索并安装 java Extension Pack 搜索并安装 Spring Boot Extension Pack 重启编辑器 以上两个扩展已关联java项目开发主要使用的maven、springboot等所需要的扩展。 配置 maven、java 扩展包点左下角的设置图标-&gt;设置 // settings.json { &quot;java.home&quot;: &quot;/usr/local/soft/java/jdk-14&quot;, &quot;java.configuration.maven.userSettings&quot;: &quot;/url/local/soft/maven/apache-maven-3.6.3/conf/settings.xml&quot;, &quot;maven.executable.path&quot;: &quot;/usr/local/soft/maven/apache-maven-3.6.3/bin/mvn&quot;, &quot;maven.terminal.useJavaHome&quot;: true, &quot;maven.terminal.customEnv&quot;: [ { &quot;environmentVariable&quot;: &quot;JAVA_HOME&quot;, &quot;value&quot;: &quot;/usr/local/soft/java/jdk-14&quot; } ] } 主要的配置信息，如上。 创建一个 Spring Boot 项目 输入Ctrl + Shift + P 打开命令面板，按照以下步骤填写相应内容即可： 输入Spring，选择maven类型工程 选择工程的语言：java 填写工程的Group Id：com.test 填写工程的ArtifactId：demo 选择springboot版本：2.0.5 搜索添加你需要的依赖库，鼠标单击可勾选，这里只添加以下几个：DevTools（代码修改热更新，无需重启）、Web（集成tomcat、SpringMVC）、Lombok（智能&gt; 生成setter、getter、toString等接口，无需手动生成，代码更简介） 选定依赖库后回车，然后选择一个目录用于初始化工程文件，最后会提示是否打开工程目录，点”open it”，或者自己手动从编辑器左侧的文件-打开文件夹-选定刚才这个目录即可。 配置运行环境启动工程之前还需要配置下运行环境，点左边的小虫子图标，然后点上面的下拉箭头，选择添加配置，VS Code会自动为我们创建启动配置，我们只要修改mainClass就好了，配置示例如下： { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;type&quot;: &quot;java&quot;, &quot;name&quot;: &quot;CodeLens (Launch) - DemoApplication&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;mainClass&quot;: &quot;com.example.demo.DemoApplication&quot;, &quot;projectName&quot;: &quot;demo&quot; } ] } 按F5或者点 DemoApplication.java 的 run 按钮启动，此时在命令行可知tomcat服务已经启动，端口号是8080，访问路径根目录为空。 在浏览器访问 http://localhost:8080提示如下错误： Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback. Mon Mar 30 19:41:47 CST 2020There was an unexpected error (type=Not Found, status=404).No message available 这说明我们的服务确实启动可用了，但是访问出这个错误，是因为我们没有定义服务器访问这个根路径对应的应答接口导致的。我们在 demo 包下面新建个 controller 包，然后新建个 HomeController.java 文件，内容如下： package com.example.demo.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HomeController { @RequestMapping(&quot;/&quot;) public String home(){ return &quot;你好，欢迎使用Visual Studio Code!&quot;; } } 此时等待 应用重启，再次访问 http://localhost:8080 你好，欢迎使用 Visual Studio Code! 写在最后欢迎使用 *Visual Studio Code *！ 参考文章 原文链接：https://blog.csdn.net/xiaocy66/java/article/details/82875770","categories":[],"tags":[{"name":"liunx","slug":"liunx","permalink":"https://blog.sharef.top/tags/liunx/"},{"name":"java","slug":"java","permalink":"https://blog.sharef.top/tags/java/"},{"name":"vscode","slug":"vscode","permalink":"https://blog.sharef.top/tags/vscode/"}]},{"title":"在 win 10 环境下 如何打造一套适合的开发环境之前端环境","slug":"how-to-build-node-env","date":"2020-02-20T16:00:00.000Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"2020/02/21/66b0ce80-95f9-11ea-926e-6f56d5e2c488/","link":"","permalink":"https://blog.sharef.top/2020/02/21/66b0ce80-95f9-11ea-926e-6f56d5e2c488/","excerpt":"前提 win10 专业版 如果安装的是 win10 企业版本呢，由于太纯净了，连应用商店都没有，我们需要自己去下载一下应用商店 开启 Linux 子系统服务 操作 步骤： 打开 控制面板 找到 程序 点击 启用或关闭 Windows 功能 在差不多倒数的几个，找到 适用于Linux 的 Windows 子系统 ，打勾，等待安装好后，重启电脑 安装 Linux 子系统 打开 应用商店，如果没有登陆，需要实现登录 一下 搜索 Linux 选择 Ubuntu 18.04 LTS 选择安装，如果下载速度较慢，可以打开传递优化 等待下载好后，直接启动就好，此处一般时间比较长，请耐心等待，开启后，设置自己的 用户名 和 密码 启动配置 Ubuntu 这里可以根据自身来配置一些东西，比如替换镜像为国内阿里源，具体的配置还需要，自己去查就好， 如果要使用 root 权限，直接使用 sudo + commend 就好 安装编辑器这里可选择 vscode 为例，因为 vsCode 有现成的插件可以很好的在 wsl 中调试代码、共享文件","text":"前提 win10 专业版 如果安装的是 win10 企业版本呢，由于太纯净了，连应用商店都没有，我们需要自己去下载一下应用商店 开启 Linux 子系统服务 操作 步骤： 打开 控制面板 找到 程序 点击 启用或关闭 Windows 功能 在差不多倒数的几个，找到 适用于Linux 的 Windows 子系统 ，打勾，等待安装好后，重启电脑 安装 Linux 子系统 打开 应用商店，如果没有登陆，需要实现登录 一下 搜索 Linux 选择 Ubuntu 18.04 LTS 选择安装，如果下载速度较慢，可以打开传递优化 等待下载好后，直接启动就好，此处一般时间比较长，请耐心等待，开启后，设置自己的 用户名 和 密码 启动配置 Ubuntu 这里可以根据自身来配置一些东西，比如替换镜像为国内阿里源，具体的配置还需要，自己去查就好， 如果要使用 root 权限，直接使用 sudo + commend 就好 安装编辑器这里可选择 vscode 为例，因为 vsCode 有现成的插件可以很好的在 wsl 中调试代码、共享文件 下载地址：https://code.visualstudio.com/docs/?dv=win 安装插件： 直接搜索 @idms-vscode-remote.remote-wsl 安装，关于更多 wsl 在 vs 中使用，可参考 https://aka.ms/vscode-remote/wsl/getting-started 其他的插件可根据自身去 下载、安装，比如 中文包、主题、图标等 重启编辑器 在 ubuntu 中安装 开发环境此处以安装 nodejs 为例，打开 vscode 编辑器，按 ctrl + ` 打开终端，此时发现还是 win10 的命令行，我们可以点击左侧边栏的 远程资源管理器，进入到 wsl 列表中，选中我们刚刚安装的 ubuntu18.04 ，此时会重新开一个窗口，这时我们在 打开终端，我们会发现已经进入到我们的 Linux 系统了。 安装 nodejs 所有命令以及操作如下： // 获取最新的node二进制包 $ wegt https://npm.taobao.org/mirrors/node/v12.16.1/node-v12.16.1-linux-x64.tar.xz // 解压node包 $ tar -xvf node-v12.16.1-linux-x64.tar.xz // 建立 nodejs 文件夹 并将解压好的移入 nodejs 文件夹 $ cd /usr/local/ $ sudo mkdir -p soft/nodejs // 不要一味的赋值，看清自己下载的版本 $ sudo mv ~/node-v12.16.1-linux-x64/* ./nodejs/ // 建立软连接 $ sudo ln -s /usr/local/soft/nodejs/bin/node /usr/local/bin/node $ sudo ln -s /usr/local/soft/nodejs/bin/npm /usr/local/bin/npm $ sudo ln -s /usr/local/soft/nodejs/bin/npx /usr/local/bin/npx // 测试安装成功与否,如果打印出版本信息，则安装成功，如果没有，则应细细检查步骤，重复一下 $ npm -v // 6.13.4 $ node -v // v12.16.1 $ npx -v // 6.13.4 // 如果在生产服务器上，可以用ftp上传 // 注意，如果在生产服务器上安装时，最好是建立一个node的用户，方便管理，由于是本地开发我们就可以随自己喜好了 测试刚刚搭建好的开发环境在 win10 中，新建一个项目文件夹，右键用 vscode 打开，在左下角点击绿色的双对箭头(&gt;&lt;)图标,选择 Reopen Folder in WSL，按 ctrl + ` 进入命令行，如下： ****@***:/mnt/c/project$ 由路径可一看出来，我们的工程目录已经自动挂载到Linux系统重量。 打开 linux 子系统的文件\\\\wsl$\\Ubuntu-18.04\\home\\ 此时请享受，在linxu环境下，带来的畅快体验，可以避免大量由于Windows的原因导致的坑点。 写在最后请认真反复","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.sharef.top/categories/linux/"},{"name":"前端","slug":"前端","permalink":"https://blog.sharef.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://blog.sharef.top/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"liunx","slug":"liunx","permalink":"https://blog.sharef.top/tags/liunx/"},{"name":"node","slug":"node","permalink":"https://blog.sharef.top/tags/node/"}]},{"title":"利用自己的云服务器搭建内网穿透，免费不限量，主要是速度很给力","slug":"frp","date":"2018-09-04T14:49:18.000Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"2018/09/04/fc6247d0-9679-11ea-8eb3-976c7845fdb4/","link":"","permalink":"https://blog.sharef.top/2018/09/04/fc6247d0-9679-11ea-8eb3-976c7845fdb4/","excerpt":"前言最近在开发一款基于微信的产品，这里不得不说，超哥 的 wechatSdk 确实好用，节省了不少时间，但是在本地开发总是会用到内网穿透来实现和微信服务器联调的环节。以前也用户过诸如 natapp 类的工具，一个原因是因为，这类工具都是需要费用的，虽然有免费的版本，但是总是会掉线，而且还是限流量。也用过Ngnok，但是如果自己搭建起来比较麻烦，失败率太高了。直接用的话，服务器在国外，在天朝访问你懂的，那是相当的缓慢，一袋烟的功夫过去了，还是个毛都没有，微信接口验证，通过的话，还得看运气。而且每次一个网址只能是用八小时左右，这就需要每次都得到公众号里面重新配置。额……又得等。之前偶然间发现，一个国人开源的神器 frp ，真的是太棒了，这里分下能给大家。具体能实现的功能，文档里面有详细的说明，我就不罗嗦了。给大家中文文档。接下来给大家分享一下搭建步骤，也是一个备忘，有好东西当然是要分享了。对了，最近开发微信公众平台需要一些测试用户，希望大家帮忙关注一下，不会给您带来困扰的，这里谢谢各位了。","text":"前言最近在开发一款基于微信的产品，这里不得不说，超哥 的 wechatSdk 确实好用，节省了不少时间，但是在本地开发总是会用到内网穿透来实现和微信服务器联调的环节。以前也用户过诸如 natapp 类的工具，一个原因是因为，这类工具都是需要费用的，虽然有免费的版本，但是总是会掉线，而且还是限流量。也用过Ngnok，但是如果自己搭建起来比较麻烦，失败率太高了。直接用的话，服务器在国外，在天朝访问你懂的，那是相当的缓慢，一袋烟的功夫过去了，还是个毛都没有，微信接口验证，通过的话，还得看运气。而且每次一个网址只能是用八小时左右，这就需要每次都得到公众号里面重新配置。额……又得等。之前偶然间发现，一个国人开源的神器 frp ，真的是太棒了，这里分下能给大家。具体能实现的功能，文档里面有详细的说明，我就不罗嗦了。给大家中文文档。接下来给大家分享一下搭建步骤，也是一个备忘，有好东西当然是要分享了。对了，最近开发微信公众平台需要一些测试用户，希望大家帮忙关注一下，不会给您带来困扰的，这里谢谢各位了。 搭建前端准备工作 拥有独立公网IP的云服务器； 会简单的liunx命令； 需要一丢丢耐心。 这里我演示的环境： 公网服务器：系统：ubuntu16.04 ** ip：x.x.x.x **开放端口：7000（绑定frp） 7500（虚拟机） 作用：用来做内网穿透的服务器 内网服务器（虚拟机）：系统：centos7 ** ip：192.168.43.133 **开放端口： 22 作用：用来实现通过外网访问，ssh登陆虚拟机 内网（win 10_64bit）： 作用：演示 本地通过访问外网实现访问本地服务器 公网服务器与内网服务器都需要下载frp进行安装，公网服务器（服务端) 实际操练 1.下载：wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz2.解压好：tar -zxvf frp_0.13.0_linux_amd64.tar.gz3.进入解压目录 cd frp_0.13.0_linux_amd644.这里主要关注4个文件，分别是frpc、frpc.ini和frps、frps.ini，前者两个文件是客户端所关注文件，后者两个文件是服务端所关注两个文件。5.配置服务端（公网服务器）vim ./frps.ini: [common] bind_port = 7000 #与客户端绑定的进行通信的端口 vhost_http_port = 80 #访问客户端web服务自定义的端口号 subdomain_host = test.com # 泛域名解析到 公网IP：x.x.x.x token = 123456 #验证客户端6.保存然后启动服务./frps -c ./frps.ini，这是前台启动，后台启动命令为nohup ./frps -c ./frps.ini &amp; 7.在win10_64bit 中下载 这个。8.配置客户端（内网）vim ./frpc.ini: [common] server_addr = x.x.x.x server_port = 7000 token = 123456 # 用于验证服务端 [web] type = http local_ip = 127.0.0.1 local_port = 80 subdomain = paper # 二级域名 访问时 即: paper.test.com [ssh] type = tcp local_ip = 192.168.43.133# 虚拟机的内网ip local_port = 22 #虚拟机的ssh端口 remote_port = 8085 #在云服务器记得放行此端口,注意这里不需要在服务端指定 9.保存然后执行./frpc -c ./frpc.ini启动，这是前台启动 10、具体访问:ssh -oPort=8085 shijf@x.x.x.x 相当于在内网使用 ssh shijf@192.168.43.133打开浏览器访问 http://paper.test.com 注意这里内网穿透并不能直接穿透到我们的内网域名,即 local_ip设置为 local_ip = paper.test 它还是访问到 默认的 127.0.0.1这里可以 使用 将 paper.test 的端口修改为 81:,那么我们可以在 客户端你这样设置:local_port = 81这样当你访问 http://paper.test.com 就可以直接 访问到 内网域名了,记得在 内网服务器也改 http://paper.test.com 的监听端口为 81. 总结这里安利这么久,确实时因为它,真的不错,访问速度快(当然取决于你的云服务器的带宽和内网服务器的配置),如果你也正好在开发微信应用,不如试试吧.","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.sharef.top/tags/linux/"},{"name":"微信开发","slug":"微信开发","permalink":"https://blog.sharef.top/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"}]},{"title":"盼望着，盼望着 let's encrypt 泛域名野卡证书，终于终于上线了","slug":"ssl-free-encrtry","date":"2018-07-30T06:03:45.000Z","updated":"2020-10-14T16:56:10.381Z","comments":true,"path":"2018/07/30/a545f2b0-967b-11ea-a177-d1521733a308/","link":"","permalink":"https://blog.sharef.top/2018/07/30/a545f2b0-967b-11ea-a177-d1521733a308/","excerpt":"说明首先说下，什么叫泛域名，假如我有一个域名 sharef.top ,那么主域名就是 www.sharef.top , 假如还想做一个网站，域名为 f.sharef.top ,如果要想 访问这两个网站，那么我们得同时将我们的这两个域名A记录解析到服务器的IP，同样，假如我们需要为这两个网站 申请 ssl 证书，那么我们要申请两个，来配置。但是泛域名解析的话，我们只需要将 * .sharef.top 这一条 A 记录解析到我们的服务器就好了，那么不管我们，想要访问a.sharef.xin,还是 b.sharef.top 都会解析到 我们的服务器。同样 泛域名解析 也是一样，我们只需申请一次的 .sharef.top 证书，我们这里的 二级域名都是可以 用这一个 ssl 证书就可以了。","text":"说明首先说下，什么叫泛域名，假如我有一个域名 sharef.top ,那么主域名就是 www.sharef.top , 假如还想做一个网站，域名为 f.sharef.top ,如果要想 访问这两个网站，那么我们得同时将我们的这两个域名A记录解析到服务器的IP，同样，假如我们需要为这两个网站 申请 ssl 证书，那么我们要申请两个，来配置。但是泛域名解析的话，我们只需要将 * .sharef.top 这一条 A 记录解析到我们的服务器就好了，那么不管我们，想要访问a.sharef.xin,还是 b.sharef.top 都会解析到 我们的服务器。同样 泛域名解析 也是一样，我们只需申请一次的 .sharef.top 证书，我们这里的 二级域名都是可以 用这一个 ssl 证书就可以了。 官方参考GitHub：仓库在这里官方中文说明：中文文档DNSAPI：你可能会是不同的DNS服务商，在 这里会查到 环境准备首先你要有一台公网服务器：这里我以 阿里云的 centos 7 为例演示：需要安装一些必要的软件 ： yum update &amp;&amp; yum install curl -y &amp;&amp; yum install cron -y &amp;&amp; yum install socat -y以下操作也可以参考官方文档哈 使用阿里云域名 api 申请Let’s Encrypt泛域名免费ssl证书下载 acme.sh 并且执行curl https://get.acme.sh | sh获取阿里云的Access Key ID和Access Key Secret到环境变量中阿里云的Access Key ID和Access Key Secret可以在下面这个页面中登录获取 执行以下命令，将密钥添加到环境变量中 export Ali_Key=&quot;你的Access Key ID&quot; export Ali_Secret=&quot;你的 Access Key Secret&quot; 申请证书执行以下命令（将domain.com换成自己的域名）： ~/.acme.sh/acme.sh --issue --dns dns_ali -d domain.com -d *.domain.com注意：第一个 -d 后不可直接写通配符域名*.domain.com，一定要写个单域名，第二个 -d 后面可以写泛域名。否则可能会出现签发的证书无法被信任的情况。 之后把这些证书下载下来就好了，所有文件在.acme.sh/你的域名 目录下面就可以了配置 ssl 的问题就 自行 搜索教程吧，证书都有啦，还怕搞不成？ 重重之中，记得放行服务器 443端口参考链接 作者：Noisky let’s encrypt泛域名野卡证书配置笔记 作者：bboysoul 使用阿里云域名api申请Let’s Encrypt泛域名免费ssl证书","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://blog.sharef.top/tags/%E5%B7%A5%E5%85%B7/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://blog.sharef.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"教程","slug":"前端/教程","permalink":"https://blog.sharef.top/categories/%E5%89%8D%E7%AB%AF/%E6%95%99%E7%A8%8B/"},{"name":"flex","slug":"前端/教程/flex","permalink":"https://blog.sharef.top/categories/%E5%89%8D%E7%AB%AF/%E6%95%99%E7%A8%8B/flex/"},{"name":"linux","slug":"linux","permalink":"https://blog.sharef.top/categories/linux/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://blog.sharef.top/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"php","slug":"php","permalink":"https://blog.sharef.top/tags/php/"},{"name":"nodejs","slug":"nodejs","permalink":"https://blog.sharef.top/tags/nodejs/"},{"name":"vue","slug":"vue","permalink":"https://blog.sharef.top/tags/vue/"},{"name":"css","slug":"css","permalink":"https://blog.sharef.top/tags/css/"},{"name":"liunx","slug":"liunx","permalink":"https://blog.sharef.top/tags/liunx/"},{"name":"java","slug":"java","permalink":"https://blog.sharef.top/tags/java/"},{"name":"vscode","slug":"vscode","permalink":"https://blog.sharef.top/tags/vscode/"},{"name":"node","slug":"node","permalink":"https://blog.sharef.top/tags/node/"},{"name":"linux","slug":"linux","permalink":"https://blog.sharef.top/tags/linux/"},{"name":"微信开发","slug":"微信开发","permalink":"https://blog.sharef.top/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"},{"name":"工具","slug":"工具","permalink":"https://blog.sharef.top/tags/%E5%B7%A5%E5%85%B7/"}]}