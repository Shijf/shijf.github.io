---
uuid: a625aad0-afd6-11ea-9390-270475cb65e3
title: 用 js 模拟 php __callstatic魔术方法
tags:
  - php
  - nodejs
categories: []
date: 2020-06-16 21:29:02
---

## php 中 的__callStatic()

```php
<?php
/**
 * 魔术方法:__call()和__callStatic()
 * __call($name, $arguments):调用类中不存在的动态方法,自动调用
 * __callStatic($name, $arguments):调用类中不存在的静态方法,自动调用
 * 以上二个魔术方法实现了方法的重载
 */
require 'call_back.php';
class Call_1
{
    //调用动态方法
    public function __call($name, $arguments)
    {
        //打印出方法名和参数，参数是在数组$arguments中
//        return '<p>方法名：'.$name.',参数是:('.implode(',',$arguments).')</p>';
        //跨类调用方法
        //call_user_func_array($method,$array_param);
//        print_r($arguments);
        //call_user_func_array([对象,'方法名',参数数组])
       return call_user_func_array([(new Call_2()),$name],$arguments);
    }
    //调用静态方法
    public static function __callStatic($name, $arguments)
    {
        return call_user_func_array(['Call_2',$name],$arguments);
    }
}
//动态
$obj = new Call_1();
echo $obj->hello(1,2,3);//输出6，成功调用了Call_2类中的方法
echo '<hr>';
//静态
echo $obj->add(1,100);//结果输出5050，成功调用了Call_2类中的add（）方法
```

## js 中可以借助 proxy 来高效实现 php中的 __callStatic()方法

```js
// index.js
/**
 * @description: 工厂函数
 * @param {null} 
 * @return: 对应的实例
 */
class Factory {
    static make(){
        const application = require(`./lib/platform/${Factory.staticName}/application`)
        return new application(arguments[0])
    }
}
// 数据劫持
var P = new Proxy(Factory, {
    get: (target, property) => {    
        target.staticName = property;
        return target.make;
    }
});

P.wwlocal('这是一份配置');
```
//需要导入的包
```js
// ./lib/platform/wwlocal/application
class Application {
    constructor(config){
        console.log('我收到的'+ config );
    }
}

module.exports = Application
```
在 index.js 中调用 P.wwlocal('这是一份配置'), 可以 很方便的导入 ./lib/platform/wwlocal/application，并返回实例，这样可以：
1. 减少代码量
2. 调用方便

**建议在nodejs高版本的使用，否则可以用Object。property来改造下这个数据劫持方法**

