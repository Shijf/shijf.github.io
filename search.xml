<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Record the practical operation of obtaining website authentication</title>
      <link href="/2020/07/25/b6bc2650-ce79-11ea-82bc-d1527d13cbe6/"/>
      <url>/2020/07/25/b6bc2650-ce79-11ea-82bc-d1527d13cbe6/</url>
      
        <content type="html"><![CDATA[<!-- * @Github: https://github.com/shijf * @Author: shijf * @Date: 2020-07-25 21:19:02 * @LastEditTime: 2020-07-25 21:19:38 * @LastEditors: shijf * @FilePath: /sharef.top/source/_posts/Record the practical operation of obtaining website authentication.md * @Description: --> <h1 id="记一次获取网站鉴权的实践操作"><a href="#记一次获取网站鉴权的实践操作" class="headerlink" title="记一次获取网站鉴权的实践操作"></a>记一次获取网站鉴权的实践操作</h1><blockquote><p>在移动端平台（就先简称PF平台）上新应用，一般会经过安全校验。所以每一个应用都会采取一些攻击策略手段来保障应用的安全稳定。一般是 xss 攻击，不过针对今天举例的系统（就先简称为BCP）他做的还是很棒的。还有就是鉴权登录，这也是主要能攻破BCP系统的关键点。</p><p>另外本文只分析破解过程，对于原理和一些名词不做过多解释。</p></blockquote><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><p>fillder（抓包工具，这个其实有没有都行，主要是爬取接口的时候，可以比较直观的。）</p></li><li><p>谷歌浏览器</p></li><li><p>PostMan（用户发送接口请求）</p></li></ul><h2 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h2><h3 id="xss-诱导攻击"><a href="#xss-诱导攻击" class="headerlink" title="xss 诱导攻击"></a>xss 诱导攻击</h3><p>BCP系统这方面考虑的比较全面，暂且不分析了。</p><h3 id="最高鉴权获取"><a href="#最高鉴权获取" class="headerlink" title="最高鉴权获取"></a>最高鉴权获取</h3><p>这也是本篇文章要重点分析的部分。</p><h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>打开PF平台上的 BCP 系统，在网络请求中发现，这样一个接口：</p><ul><li><p>url：<code>jtsi/UserLogin/login</code> </p></li><li><p>method：POST</p></li><li><p>作用：用户登录，返回用户登录信息</p></li><li><p>参数字段：</p><table><thead><tr><th>字段</th><th>取值（爬取发现）</th><th>类型</th><th>是否必填</th><th>说明</th></tr></thead><tbody><tr><td>deviceType</td><td>D</td><td>string</td><td>是</td><td>判断设备类型，貌似没啥用，不断啥就用D这个值就行</td></tr><tr><td>domain</td><td>BCPWx</td><td>string</td><td>否</td><td>用来判断是否是在 移动端 ，移动端就是 BCPWx，PC端啥也不写</td></tr><tr><td>timestamp</td><td>1595656277</td><td>number</td><td>是</td><td>时间戳，应该是为了标识当前调用的事件</td></tr><tr><td>login_type</td><td>login_user</td><td>string</td><td>是</td><td>用户登录类型，用 login_user 这个就行</td></tr><tr><td>passwd</td><td>BcpWx%3c6****efbe84%3E</td><td>string</td><td>是</td><td>用户的密码（为了安全，我进行了脱密处理），下文会重点分析，这个字符串，关键突破点</td></tr><tr><td>t</td><td>1595656277720</td><td>number</td><td>是</td><td>又来一个时间戳，不过这个是 毫秒 的，上面的 timestamp 是秒的。</td></tr></tbody></table></li><li><p>返回参数：</p><pre><code class="josn">{  &quot;Result&quot;: true,  &quot;ReturnCode&quot;: &quot;000&quot;,  &quot;ReturnMessage&quot;: {      &quot;orgName&quot;: &quot;******团队&quot;,       &quot;roleIds&quot;: [&quot;-1&quot;],      &quot;statusMsg&quot;: &quot;登录成功&quot;,      &quot;domain&quot;: &quot;&quot;,      &quot;sessionId&quot;: &quot;5d1116fb-****-****-94ac-96fa19c75d30&quot;,      &quot;userName&quot;: &quot;***&quot;,      &quot;userId&quot;: &quot;********&quot;,      &quot;orgId&quot;: &quot;**********&quot;,      &quot;depts&quot;: {          &quot;num&quot;: &quot;1&quot;,          &quot;**********&quot;: &quot;****团队&quot;      },      &quot;status&quot;: 1,      &quot;token&quot;: &quot;5d1116fb-****-****-94ac-96fa19c75d30&quot;  }}</code></pre></li></ul><p>从上面的请求参数开始分析：</p><ul><li><p>第一步：</p><p>BCP 系统的致命漏洞，也是出现在此。用户在经过 PF 平台的 Oauth2 授权后，竟然没有直接返回 token 值，而是在Oauth2 授权拿到 用户id 后，神奇的是又去请求 BCP 系统自带的登录接口（UserLogin/login），那么他就需要账号密码。</p></li><li><p>第二步：</p><p>通过第一步发现，系统在登陆前，肯定会有一次获取用户密码的请求，果不其然，在进一步抓包处理后（由于只是在手机端简单的注入了一些检测脚本，所以并没有拿到返回密码的接口，或者说在我注入脚本之前，系统就已经完成了获取密码操作，所以我一开始没有拿到这个接口），发现了一个返回用户密码的接口，这个稍后再分析。</p></li><li><p>第三步：</p><p>第二步说到：会有一个返回密码的接口，那么我们要想获取到最高权限（系统管理员）的密码，就必然得知道管理员（当然我是知道，该系统的管理员的用户id，不知道也没关系，下文会讲解怎么拿）的账号密码。</p></li></ul><h4 id="获取管理员账号1"><a href="#获取管理员账号1" class="headerlink" title="获取管理员账号1"></a>获取管理员账号1</h4><p>上文说到，我已经知道管理员的帐号了，因为就是系统负责人，我肯定是知道的，假如说我不知道，怎么办？</p><p>大家知道，在公司内部一般的员工编号都是数字或者有规律的，最主要的就是可以根据自己的账号去推演，毕竟破解最多的就是穷举法。</p><p>为了更好的解释怎么获取管理员账号，我在下文会提到根据什么原理拿到管理员账号，此处假设我们知道管理员的账号了。</p><h4 id="寻求加密突破点"><a href="#寻求加密突破点" class="headerlink" title="寻求加密突破点"></a>寻求加密突破点</h4><p>我们再一次回到，在移动端发现的登录接口，分析一下，此处的请求参数：passwd，为了解释简单，我们假设一个账号：12345678，他的密码（当然我是根据他的规律来生成的）是：BcpWx%3c25d55ad283aa400af464c76d713c07ad%3e，根据经验（也是常识），在接口传参数的时候我们不会有%号的出，也是我们是通过抓包拿到的字符串，肯定也会经过URL编码，那么我们反编码一下：BcpWx&lt;25d55ad283aa400af464c76d713c07ad&gt;，这个规律就有了，密码应该是加密过的，加密过后应该是：25d55ad283aa400af464c76d713c07ad，然后开发者又在密码前后分别加了 “BcpWx&lt;” 和 “&gt;”，当然如果你经验够足的话，一眼就能判断 “&gt;” 的url 编码 为 %3c， “&lt; “的编码为 %3e。那么就只剩下 25d55ad283aa400af464c76d713c07ad ，咋一看，这咋解密，无从下手，上文说到，破解、攻击等手段常用的就是穷举法（没想到第一个 BCP 就中了），最常用的就是 md5 加密，不管三七二十一，先来一波md5加密：</p><table><thead><tr><th>字符串</th><th>12345678</th></tr></thead><tbody><tr><td>16位 小写</td><td>83aa400af464c76d</td></tr><tr><td>16位 大写</td><td>83AA400AF464C76D</td></tr><tr><td>32位 小写</td><td>25d55ad283aa400af464c76d713c07ad</td></tr><tr><td>32位 大写</td><td>25D55AD283AA400AF464C76D713C07AD</td></tr></tbody></table><p><strong>注：因为我知道我得账号是多少，所以我是拿自己的 userid，通过md5 去比对的。</strong></p><p>到此返现了惊喜，md5 加密的 <strong>32位 小写</strong> 结果不就是，我们在接口中发现的字符串吗？其实到这里就已经攻破了，当前这是后来分析，才知道的。假设不知道的时候，我们就需要进一步发现。因为这个只是在移动端登录的接口，即使知道了，操作起来不太方便。接下来我们登录 PC　端看看会有怎样的发现。</p><h4 id="获取管理员账号-2"><a href="#获取管理员账号-2" class="headerlink" title="获取管理员账号 2"></a>获取管理员账号 2</h4><p>接上上小结的内容，假设你不知道管理员账号怎么办？PC 端登录，是用的公司统一认证平台，当登录到，总共请求了 3（有一个接口请求了两次，重复的，阿西吧） 接口：<code>/jtsi/UserLogin/getHeadImg</code> 、<code>/jtsi/JTApplicationService/getApplications</code>和<code>/jtsi/JTApplicationService/getApplicationMenu</code></p><p>第一个顾名思义，请求头像的不用管，重点部分是后边两个接口，超管也顾名思义，啥都管，那么他的应用和菜单树肯定是最多的，只要根据公司的员工编号，写个批量小脚本，哪个员工的菜单树最多，他肯定就是超管了就没跑了。也有的是 admin 这种。</p><h4 id="接口小技巧"><a href="#接口小技巧" class="headerlink" title="接口小技巧"></a>接口小技巧</h4><p>根据pc端的接口请求可以看出，BCP 系统鉴权使用的 token （移动端）和 sessionId （PC端），这也就不难理解，为啥在 <code>jtsi/UserLogin/login</code> 的返回结果中，为啥既有 token 还有 sessionId 了，但是他忽略了一点，也是 BCP 系统最致命的。从返回结果我们可以得出两个结论：</p><ol><li>后台生成 token 和 sessionId 的机制一样，只是换了个名称而已</li><li>我们可以利用移动端生成的密码，去获取 token，而此处的 token也即 PC端的 sessionId </li></ol><p>为什么要用移动端的接口去生成 token（sessionId ） 呢，上文说到，PC端登录和移动端登录时，是通过 domain 参数来判断的，加入我们不填 domain 参数，你会发现，用 md5 生成的密码对 PC 端的登录接口没用的，这也引发了我继续探寻下去的兴趣。</p><a id="more"></a><h4 id="探寻PC端登录接口"><a href="#探寻PC端登录接口" class="headerlink" title="探寻PC端登录接口"></a>探寻PC端登录接口</h4><p>上一节说到，如果想用 md5 的密码来获取 token，我们怎么办呢？看一下 PC 的登录接口，在登录的一瞬间，我抓到三个接口：<code>/jtsi/IAMService/getUserInfo</code> 、<code>/jtsi/UserLogin/generatorKey</code> 和 <code>/jtsi/UserLogin/login</code></p><ul><li><p>getUserInfo (根据统一认证平台返回的code，拿到当前用户id，其实都拿到 id 了，还进行以下两步，哎)</p><p>请求参数：</p></li></ul><pre><code class="json">  {    &quot;code&quot;: &quot;e829b71a*******5d803903b82&quot;,    &quot;url&quot;: &quot;http://**************/jtcl/bcp-eb/initial.html&quot;,    &quot;domain&quot;: &quot;&quot;,    &quot;deviceType&quot;: &quot;D&quot;  }</code></pre><pre><code>  返回响应(移动端也是因为这个出现的漏洞)：</code></pre><pre><code class="json">{    &quot;Result&quot;: true,    &quot;ReturnCode&quot;: &quot;000&quot;,    &quot;ReturnMessage&quot;: {        &quot;password&quot;: &quot;BcpIAMLogin&lt;069*********2f8346768&gt;&quot;,        &quot;userId&quot;: &quot;********&quot;    }}</code></pre><ul><li><p>generatorKey（多次调用后发现，这个加密 key 居然是固定不变的，即每个人都是固定的一个值，那么我们只需要获取一次，就可以拿到该用户的密码）</p><p>请求参数：</p></li></ul><pre><code class="json">  {      &quot;userId&quot;: &quot;********&quot;,      &quot;domain&quot;: &quot;&quot;,      &quot;deviceType&quot;: &quot;D&quot;  }</code></pre><pre><code>  返回响应：</code></pre><pre><code class="json">{    &quot;Result&quot;: true,    &quot;ReturnCode&quot;: &quot;000&quot;,    &quot;ReturnMessage&quot;: {        &quot;type&quot;: &quot;AES&quot;,        &quot;key&quot;: &quot;8NON*******ysWpM&quot;    }}</code></pre><ul><li><p>login（登录接口，返回 sessionId）</p><p>请求参数：</p></li></ul><pre><code class="json">{    &quot;userId&quot;: &quot;********&quot;,    &quot;domain&quot;: &quot;&quot;,    &quot;deviceType&quot;: &quot;D&quot;,    &quot;login_type&quot;: &quot;login_user&quot;,    &quot;passwd&quot;: &quot;GasFj9PbWBEgr%2FU7IDI%2B1Eg5rtbVDI9KEK38dr%2Fcg%2BOWZk***zcwa4GP1qO&quot;, // 一般有百分号的都是经俩编码的，记得解码    &quot;timestamp&quot;: 1595642745}</code></pre><p>​    返回响应：</p><pre><code class="json">{    &quot;Result&quot;: true,    &quot;ReturnCode&quot;: &quot;000&quot;,    &quot;ReturnMessage&quot;: {        &quot;orgName&quot;: &quot;****团队&quot;,        &quot;roleIds&quot;: [&quot;-1&quot;],        &quot;statusMsg&quot;: &quot;登录成功&quot;,        &quot;domain&quot;: &quot;&quot;,        &quot;sessionId&quot;: &quot;5d1116fb-****-****-94ac-96fa19c75d30&quot;,        &quot;userName&quot;: &quot;***&quot;,        &quot;userId&quot;: &quot;********&quot;,        &quot;orgId&quot;: &quot;******0***&quot;,        &quot;depts&quot;: {            &quot;num&quot;: &quot;1&quot;,            &quot;******0***&quot;: &quot;***团队&quot;        },        &quot;status&quot;: 1,        &quot;token&quot;: &quot;5d1116fb-****-****-94ac-96fa19c75d30&quot;    }}</code></pre><p>从上面三个接口可以看出，是依次递进的，先通过 <strong>getUserInfo</strong> 拿到 用户账号即 userId , 再通过 <strong>generatorKey</strong> 拿到加密密钥（后面会讲这个用处，以及好玩之处），最后通过 *<em>login *</em>接口，获得 sessionId 来登录系统。</p><p>思路理清后，好像还是不能获得 PC 端登录时的密码是啥，即 <code>domain</code>参数为空时，调用 login 接口。但是通过第二个接口，可以给我们一些惊喜，我们分析一下BCP系统的前端登录逻辑：</p><p>拿到 login.js 文件（本文只显示关键代码）：</p><pre><code class="js">// ……部分代码reqData.userId = userId; // 这个是 用户的idvar keyAction = loginAction.generatorKey; // 获取 key 的接口的 方法jt.ajax(keyAction, reqData, function(resData){ // 上文中提到的第二个接口即获取 key 值，就是这句代码来 执行后发出的请求if(resData &amp;&amp; resData.type &amp;&amp; resData.key){     var encryptType = resData.type; // 拿到 key 值的加密 类型，即加密密码时，是采用哪种加密方式    var encryptKey = resData.key; // 获取加密时，需要的密钥    passwd = jt.util.encryptString(passwd, encryptKey, encryptType); // 加密代码，都是在前端加密的，这个开发者真是o((⊙﹏⊙))o.，我们可以在控制台调用这个方法，来获取方法    passwd = encodeURIComponent(passwd); // 开发者可能觉得上边的加密，还需要 编码以下    }    jt.security.login(loginAction.login, userId, passwd, $scope.myCallback, reqData); // 执行登录操作});</code></pre><p>encryptString 方法的代码(在jt.core.min.js， 这个真心应该放在后端代码中)：</p><pre><code class="js">// 加密代码var encryptString=function(plaint,key,type){type=type?type.toUpperCase():type;if(&quot;AES&quot;==type){return AESEncrypt(plaint,key)}else{if(&quot;DES&quot;==type||&quot;3DES&quot;==type){return DESEncrypt(plaint,key)}else{if(&quot;RSA&quot;==type){return RSAEncrypt(plaint,key)}else{return plaint}}}};// 解密代码，如果你不知道自己的密码，可以在控制台调用以下这个方法，O(∩_∩)Ovar decryptString=function(encrypted,key,type){type=type?type.toUpperCase():type;if(&quot;AES&quot;==type){return AESDecrypt(encrypted,key)}else{if(&quot;DES&quot;==type||&quot;3DES&quot;==type){return DESDecrypt(encrypted,key)}else{if(&quot;RSA&quot;==type){return RSADecrypt(encrypted,key)}else{return encrypted}}}};</code></pre><p>到此，我们就拿到了用户的在加密后的密码，从而也就拿到了，通过 PC 端请求接口时，即 <code>domain</code>为空时，获取到他的 token值，也就是 凭证，接下来只需要知道接口就可以为所欲为了，也就获取了鉴权权限。</p><h3 id="重点来了"><a href="#重点来了" class="headerlink" title="重点来了"></a>重点来了</h3><p>通过在PC端登录逻辑的分析，BCP系统的用户密码就是移动端请求时参数里面的密码（BcpWx%3c6****efbe84%3E），在PC端登录时，再进行加密此密码，来登录PC端。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>可能超管都不知道他的密码是啥（超管登录是通过统一认证平台登录的），因为开发者和超管不是一个人，密码也是程序批量自动生成的，他想改还不知到原密码，其实这才是最好玩的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>熟话说，破解不是目的，目的是为了学（po）习（jie）。</p><p>本文中，没有用插图，主要是为了加载速度，已经易于传播。</p><p>如果开发BCP系统的开发者能：</p><ul><li>多余参数不要，省带宽，降风险</li><li>加密在后端做</li><li>多一些开发经验</li></ul><p>那么我也不会这么轻易的拿到鉴权权限。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用 js 模拟 php __callstatic魔术方法</title>
      <link href="/2020/06/16/a625aad0-afd6-11ea-9390-270475cb65e3/"/>
      <url>/2020/06/16/a625aad0-afd6-11ea-9390-270475cb65e3/</url>
      
        <content type="html"><![CDATA[<h2 id="php-中-的-callStatic"><a href="#php-中-的-callStatic" class="headerlink" title="php 中 的__callStatic()"></a>php 中 的__callStatic()</h2><pre><code class="php">&lt;?php/** * 魔术方法:__call()和__callStatic() * __call($name, $arguments):调用类中不存在的动态方法,自动调用 * __callStatic($name, $arguments):调用类中不存在的静态方法,自动调用 * 以上二个魔术方法实现了方法的重载 */require &#39;call_back.php&#39;;class Call_1{    //调用动态方法    public function __call($name, $arguments)    {        //打印出方法名和参数，参数是在数组$arguments中//        return &#39;&lt;p&gt;方法名：&#39;.$name.&#39;,参数是:(&#39;.implode(&#39;,&#39;,$arguments).&#39;)&lt;/p&gt;&#39;;        //跨类调用方法        //call_user_func_array($method,$array_param);//        print_r($arguments);        //call_user_func_array([对象,&#39;方法名&#39;,参数数组])       return call_user_func_array([(new Call_2()),$name],$arguments);    }    //调用静态方法    public static function __callStatic($name, $arguments)    {        return call_user_func_array([&#39;Call_2&#39;,$name],$arguments);    }}//动态$obj = new Call_1();echo $obj-&gt;hello(1,2,3);//输出6，成功调用了Call_2类中的方法echo &#39;&lt;hr&gt;&#39;;//静态echo $obj-&gt;add(1,100);//结果输出5050，成功调用了Call_2类中的add（）方法</code></pre><h2 id="js-中可以借助-proxy-来高效实现-php中的-callStatic-方法"><a href="#js-中可以借助-proxy-来高效实现-php中的-callStatic-方法" class="headerlink" title="js 中可以借助 proxy 来高效实现 php中的 __callStatic()方法"></a>js 中可以借助 proxy 来高效实现 php中的 __callStatic()方法</h2><pre><code class="js">// index.js/** * @description: 工厂函数 * @param {null}  * @return: 对应的实例 */class Factory {    static make(){        const application = require(`./lib/platform/${Factory.staticName}/application`)        return new application(arguments[0])    }}// 数据劫持var P = new Proxy(Factory, {    get: (target, property) =&gt; {            target.staticName = property;        return target.make;    }});P.wwlocal(&#39;这是一份配置&#39;);</code></pre><p>//需要导入的包</p><pre><code class="js">// ./lib/platform/wwlocal/applicationclass Application {    constructor(config){        console.log(&#39;我收到的&#39;+ config );    }}module.exports = Application</code></pre><p>在 index.js 中调用 P.wwlocal(‘这是一份配置’), 可以 很方便的导入 ./lib/platform/wwlocal/application，并返回实例，这样可以：</p><ol><li>减少代码量</li><li>调用方便</li></ol><p><strong>建议在nodejs高版本的使用，否则可以用Object。property来改造下这个数据劫持方法</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 js 模拟 php __callstatic魔术方法</title>
      <link href="/2020/06/16/9624aeb0-afd6-11ea-9390-270475cb65e3/"/>
      <url>/2020/06/16/9624aeb0-afd6-11ea-9390-270475cb65e3/</url>
      
        <content type="html"><![CDATA[<h2 id="php-中-的-callStatic"><a href="#php-中-的-callStatic" class="headerlink" title="php 中 的__callStatic()"></a>php 中 的__callStatic()</h2><pre><code class="php">&lt;?php/** * 魔术方法:__call()和__callStatic() * __call($name, $arguments):调用类中不存在的动态方法,自动调用 * __callStatic($name, $arguments):调用类中不存在的静态方法,自动调用 * 以上二个魔术方法实现了方法的重载 */require &#39;call_back.php&#39;;class Call_1{    //调用动态方法    public function __call($name, $arguments)    {        //打印出方法名和参数，参数是在数组$arguments中//        return &#39;&lt;p&gt;方法名：&#39;.$name.&#39;,参数是:(&#39;.implode(&#39;,&#39;,$arguments).&#39;)&lt;/p&gt;&#39;;        //跨类调用方法        //call_user_func_array($method,$array_param);//        print_r($arguments);        //call_user_func_array([对象,&#39;方法名&#39;,参数数组])       return call_user_func_array([(new Call_2()),$name],$arguments);    }    //调用静态方法    public static function __callStatic($name, $arguments)    {        return call_user_func_array([&#39;Call_2&#39;,$name],$arguments);    }}//动态$obj = new Call_1();echo $obj-&gt;hello(1,2,3);//输出6，成功调用了Call_2类中的方法echo &#39;&lt;hr&gt;&#39;;//静态echo $obj-&gt;add(1,100);//结果输出5050，成功调用了Call_2类中的add（）方法</code></pre><h2 id="js-中可以借助-proxy-来高效实现-php中的-callStatic-方法"><a href="#js-中可以借助-proxy-来高效实现-php中的-callStatic-方法" class="headerlink" title="js 中可以借助 proxy 来高效实现 php中的 __callStatic()方法"></a>js 中可以借助 proxy 来高效实现 php中的 __callStatic()方法</h2><pre><code class="js">// index.js/** * @description: 工厂函数 * @param {null}  * @return: 对应的实例 */class Factory {    static make(){        const application = require(`./lib/platform/${Factory.staticName}/application`)        return new application(arguments[0])    }}// 数据劫持var P = new Proxy(Factory, {    get: (target, property) =&gt; {            target.staticName = property;        return target.make;    }});P.wwlocal(&#39;这是一份配置&#39;);</code></pre><p>//需要导入的包</p><pre><code class="js">// ./lib/platform/wwlocal/applicationclass Application {    constructor(config){        console.log(&#39;我收到的&#39;+ config );    }}module.exports = Application</code></pre><p>在 index.js 中调用 P.wwlocal(‘这是一份配置’), 可以 很方便的导入 ./lib/platform/wwlocal/application，并返回实例，这样可以：</p><ol><li>减少代码量</li><li>调用方便</li></ol><p><strong>建议在nodejs高版本的使用，否则可以用Object。property来改造下这个数据劫持方法</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue原理剖析之数据代理和数据递归劫持</title>
      <link href="/2020/06/13/d5e66740-ad7f-11ea-aa55-150e2fc8d2f7/"/>
      <url>/2020/06/13/d5e66740-ad7f-11ea-aa55-150e2fc8d2f7/</url>
      
        <content type="html"><![CDATA[<pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Vue原理&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        let vm = new myVue({            data: {                age: 12,                score: {                    math: 99,                    english: 89                }            }        })            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="js">class myVue {    constructor(options) {        this._options = options;        this.$data = options.data;        this._initData()    }&lt;!-- more --&gt;    _initData() {        let data = this.$data        let keys = Object.keys(data)        // 数据代理        // 实现 vm.a 可以拿到 示例中 data的a的值        for (let index = 0; index &lt; keys.length; index++) {            Object.defineProperty(this, keys[index], {                enumerable: true, // 可遍历                configurable: true, // 可被改写                get: function proxyGetter() {                    return data[keys[index]]                },                set: function proxySetter(val) {                    data[keys[index]] = val                }            })        }        // 数据劫持，data 中的任意数据有变动时 进行劫持        observe(data)    }}// 判断data是否是基础类型, 递归数data据劫持function observe(data) {    // 使用Object.prototype上的原生toString()方法判断数据类型    // 参考链接：https://blog.csdn.net/u012158998/article/details/86423270    // 判断 data 属性是否是 数组或者 对象类型    const type = Object.prototype.toString.call(data)    if (type !== &quot;[object Array]&quot; &amp;&amp; type !== &quot;[object Object]&quot;) { // 基础类型无需遍历        return;    }    // 递归处理 数据劫持    new Observer(data)}/** * 4. 实现数据劫持工具方法 * @param {*} obj 要劫持的数据 * @param {*} objKey 劫持数据的类型 * @param {*} value  劫持数据的原始值 */function defineReactive(obj, objKey, value) {    // 判断下是否可以继续遍历，由内向外的遍历    observe(obj[objKey])    Object.defineProperty(obj, objKey, {        enumerable: true, // 可遍历        configurable: true, // 可被改写        get: function proxyGetter() {            console.log(`${objKey}取值`);            return value        },        set: function proxySetter(val) {            console.log(`${objKey}发生了改变`);            value = val        }    })}// class Observer {    constructor(data) {        this._walk(data)    }    _walk(data) {        let keys = Object.keys(data)        for (let index = 0; index &lt; keys.length; index++) {            // 针对每一层开始遍历数据并劫持            defineReactive(data, keys[index], data[keys[index]])        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底搞定flex (持续更新)</title>
      <link href="/2020/06/04/074be1f0-a666-11ea-8193-9355c0848143/"/>
      <url>/2020/06/04/074be1f0-a666-11ea-8193-9355c0848143/</url>
      
        <content type="html"><![CDATA[<h1 id="flex-布局初体验"><a href="#flex-布局初体验" class="headerlink" title="flex 布局初体验"></a>flex 布局初体验</h1><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591249474353.png" alt="image"></p><p>假设我们要实现一个这样的布局，三个色块水平排版;</p><a id="more"></a><h2 id="一般写法"><a href="#一般写法" class="headerlink" title="一般写法"></a>一般写法</h2><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;flex&lt;/title&gt;    &lt;style&gt;&lt;/style&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="css">*{    margin: 0;    padding: 0;}ul {    margin: 50px;    border: 1px solid #000000;    overflow: hidden;    width: 300px;    color: #ffffff;}li {    line-height: 50px;    list-style: none;    height: 50px;    width: 50px;    background-color: blue;    text-align: center;    float: left;}ul li:first-child {    background-color: red;}ul li:last-child{    background-color: green;}</code></pre><p>从代码看出，我们用了浮动。而且浮动布局并不会撑起父元素的高度，我们还需要清除浮动(overflow: hidden;)</p><h3 id="用flex布局实现"><a href="#用flex布局实现" class="headerlink" title="用flex布局实现"></a>用flex布局实现</h3><pre><code class="css">*{    margin: 0;    padding: 0;}ul {    margin: 50px;    border: 1px solid #000000;    /* overflow: hidden; */    width: 300px;    color: #ffffff;    display: flex;}li {    line-height: 50px;    list-style: none;    height: 50px;    width: 50px;    background-color: blue;    text-align: center;    /* float: left; */}ul li:first-child {    background-color: red;}ul li:last-child{    background-color: green;}</code></pre><p>我们只需要告诉父元素，display: flex; 即可实现。是不是 so easy！</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><strong>伸缩容器</strong>： 在上述的示例中，ul 即为伸缩容器</li><li><strong>伸缩项</strong>： 伸缩容器的子元素，就是伸缩项，在上述示例中，li 为伸缩项</li><li><strong>主轴</strong>: 在默认情况下水平方向上称为<strong>主轴</strong>，主轴的从左到右 分别为 主轴的起点、主轴的终点</li><li><strong>侧轴</strong>：在默认情况下垂直方向上称为<strong>侧轴</strong>，侧轴的从上到下 分别称为 侧轴的起点、侧轴的终点</li></ul><p>图示说明：</p><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591249508155.png" alt="image"></p><h2 id="主轴方向"><a href="#主轴方向" class="headerlink" title="主轴方向"></a>主轴方向</h2><pre><code class="css">*{    margin: 0;    padding: 0;}ul {    margin: 50px;    border: 1px solid #000000;    width: 300px;    color: #ffffff;    display: flex;}li {    line-height: 50px;    list-style: none;    height: 50px;    width: 50px;    background-color: blue;    text-align: center;}ul li:first-child {    background-color: red;}ul li:last-child{    background-color: green;}</code></pre><p>以上代码的效果：</p><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591249524969.png" alt="image"></p><p>可以看到，flex 默认的排版时从左到有的，即主轴方向是水平向右的。如果需要想要从右向左，则需要修改主轴的起点方向。</p><ul><li>相关属性：flex-direction<ul><li>属性参数： row（默认：水平从左到右）row-reverse（从右到左）</li></ul></li></ul><p>我们来试一下不同的取值:</p><ul><li><code>row-reverse</code> （主轴从右到左）</li></ul><pre><code class="css">ul{    flex-direction: row-reverse;}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591249541816.png" alt="image"></p><ul><li><code>column</code>（主轴方向垂直从上到下）</li></ul><pre><code class="css">ul{    flex-direction: column;}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591249552700.png" alt="image"></p><ul><li><code>column-reverse</code> (主轴反向垂直从下到上)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591249562980.png" alt="image"></p><blockquote><p>注意点：只要主轴发生了变化，侧轴也会变化，永远都是十字交叉的。</p></blockquote><h2 id="主轴的对齐方式"><a href="#主轴的对齐方式" class="headerlink" title="主轴的对齐方式"></a>主轴的对齐方式</h2><ul><li>相关属性： justify-content</li></ul><p>相关取值效果展示：<br>注意： 此时的 <code>主轴方向</code> 为默认的 row 取值</p><ol><li>flex-start(默认) : 让伸缩项与主轴<strong>起点</strong>对齐<pre><code class="css">ul { margin: 50px; border: 1px solid #000000; width: 300px; color: #ffffff; display: flex; flex-direction: row;  justify-content: flex-start; // 修改不同的取值}</code></pre><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591256835268.png" alt="image"></li><li>flex-end ：让伸缩项与主轴<strong>终点</strong>对齐<br><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591260053670.png" alt="image"></li><li>center: 伸缩项位于主轴的中点<br><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591256879044.png" alt="image"></li><li>space-between: 两端对齐</li></ol><p>先看效果再说原理：</p><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591257094293.png" alt="image"></p><blockquote><p>每两个伸缩项间的距离 = (伸缩容器的宽度 - 所有伸缩项的宽度的总和) / (伸缩项的个数 - 1)</p></blockquote><p>伸缩项（个数大于2时）的排列规律是：起点、终点各一个，剩下的间距为 <code>每两个伸缩项间的距离</code>。<br>5.space-around 环绕对齐<br><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591263672191.png" alt="image"></p><blockquote><p>每个伸缩项的两边的距离 = (伸缩容器的宽度 - 所有伸缩项的宽度的总和) / (伸缩项的个数 * 2)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591263770552.png" alt="image"></p><p>上图中，绿色小方块的距离即为：每个伸缩项的两边的距离</p><p><strong>总结</strong>：</p><ul><li>flex-direction 告诉伸缩容器主轴的的方向</li><li>justify-content 告诉伸缩项的对齐规则</li></ul><h2 id="侧轴对齐方式"><a href="#侧轴对齐方式" class="headerlink" title="侧轴对齐方式"></a>侧轴对齐方式</h2><p>开始之前，修改下 伸缩容器 ul 的告诉为 600px；</p><pre><code class="css">ul {    margin: 50px;    border: 1px solid #000000;    width: 300px;    height: 600px;  /*增加了此处*/    color: #ffffff;    display: flex; /*默认*/    flex-direction: row; /*默认*/}</code></pre><p>相关属性：</p><ul><li>align-items 侧轴对齐方式<pre><code class="css">ul {  margin: 50px;  border: 1px solid #000000;   width: 300px;  height: 300px;  color: #ffffff;  display: flex;  flex-direction: row;  align-items: flex-start; /*增加了此处*/}</code></pre></li></ul><p>属性：</p><ul><li>flex-start（默认）和侧轴起点对齐</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591275400464.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591275504200.png" alt="image"></p><ul><li><p>flex-end： 和侧轴终点对齐<br><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591275540439.png" alt="image"></p></li><li><p>center：和侧轴中点位置对齐</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591275606306.png" alt="image"></p><ul><li>baseline 基线对齐，让所有伸缩项的基线对齐</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591275824900.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591275876712.png" alt="image"></p><p>再来个图：<br><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591275946460.png" alt="image"></p><ol><li><p>baseline的确定规则<br>a) . inline-table元素的baseline是它的table第一行的baseline<br>b). 父元素【line box】的baseline是最后一个inline box 的baseline</p></li><li><p>inline-block元素的baseline确定规则</p></li></ol><p>规则1：inline-block元素，如果内部有line box，则inline-block元素的baseline就是最后一个作为内容存在的元素[inline box]的baseline，而这个元素的baseline的确定就要根据它自身来定了。</p><p>规则2：inline-block元素，如果其内部没有line box或它的overflow属性不是visible，那么baseline将是这个inline-block元素的底margin边界。</p><p>为了看到更清楚：</p><pre><code class="css">li {    line-height: 50px;    list-style: none;    height: 50px;    width: 50px;    text-align: center;}ul li:nth-child(2) {    background-color: blue;    padding-top: 25px; /*新增的内容*/}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591276143225.png" alt="image"></p><p>可以看出，只有将第一个和第二和顶下来，才能保证三个伸缩项保持基线对齐。</p><ul><li>stretch 拉伸对齐（等高对齐） 让所有伸缩项的高度变为侧轴的高度</li></ul><pre><code class="css">ul {    margin: 50px;    border: 1px solid #000000;     width: 300px;    height: 300px;    color: #ffffff;    display: flex;    flex-direction: row;    align-items: stretch; /*修改了此处*/}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591276620047.png" alt="image"><br><strong>注意</strong>：如果要使用拉伸对齐，那么伸缩项就不能设置高度，否则会失效<br>修改代码：</p><pre><code class="css">li {     /* line-height: 50px; */ /*注释掉他*/    list-style: none;    /* height: 50px; */ /*注释掉他*/    width: 50px;    text-align: stre;}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/shijf/shijf.github.io/images/1591276712392.png" alt="image"></p><p><strong>总结</strong></p><ul><li>align-items 规定了侧轴的对齐方式</li><li>和主轴对齐属性（justify-content）相比，侧轴对齐属性没有两端对齐和环绕对齐，但是新增了其他属性</li></ul><h3 id="侧轴的对齐方式2（设置单独的某个伸缩项在侧轴的对齐方式）"><a href="#侧轴的对齐方式2（设置单独的某个伸缩项在侧轴的对齐方式）" class="headerlink" title="侧轴的对齐方式2（设置单独的某个伸缩项在侧轴的对齐方式）"></a>侧轴的对齐方式2（设置单独的某个伸缩项在侧轴的对齐方式）</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 教程 </category>
          
          <category> flex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何利用 VSCode 打造一个 java 的开发环境</title>
      <link href="/2020/05/15/30e42f40-9667-11ea-a46f-b77762f93269/"/>
      <url>/2020/05/15/30e42f40-9667-11ea-a46f-b77762f93269/</url>
      
        <content type="html"><![CDATA[<h1 id="安装-Java-环境"><a href="#安装-Java-环境" class="headerlink" title="安装 Java 环境"></a>安装 Java 环境</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="概念理解："><a href="#概念理解：" class="headerlink" title="概念理解："></a>概念理解：</h3><ul><li><p>J2SE 标准版</p></li><li><p>J2EE 企业版</p></li><li><p>J2ME 用于移动设备、嵌入式设备</p><h3 id="JRE、JDK、JVM之间的区别与联系"><a href="#JRE、JDK、JVM之间的区别与联系" class="headerlink" title="JRE、JDK、JVM之间的区别与联系"></a>JRE、JDK、JVM之间的区别与联系</h3></li><li><p>JVM ：英文名称（Java Virtual Machine），就是我们耳熟能详的 Java 虚拟机。它只认识 xxx.class 这种类型的文件，它能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。所以说，jvm 是 Java 能够跨平台的核心，具体的下文会详细说明。</p></li><li><p>JRE ：英文名称（Java Runtime Environment），我们叫它：Java 运行时环境。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。</p></li><li><p>JDK ：英文名称（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe，java.exe，jar.exe 等。</p></li></ul><p>显然，这三者的关系是：一层层的嵌套关系。JDK&gt;JRE&gt;JVM</p><a id="more"></a><h2 id="Linux-安装-Java-环境"><a href="#Linux-安装-Java-环境" class="headerlink" title="Linux 安装 Java 环境"></a>Linux 安装 Java 环境</h2><p>此处需要结合上一篇 <a href="https://blog.sharef.top/2020/02/21/66b0ce80-95f9-11ea-926e-6f56d5e2c488/">《在win 10 环境下 如何打造一套适合的开发环境》</a>，将ubuntu 设置为 主要的开发、运行环境。</p><ul><li>官网地址：<a href="https://www.oracle.com/downloads/#category-java" target="_blank" rel="noopener">https://www.oracle.com/downloads/#category-java</a> （2020/03/30版，可能链接会变化）</li><li>找到 Java -&gt; Java (JDK) for Developers 点击，目前地址 ：<a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-downloads.html</a></li><li>这里采用  Linux Compressed Archive ，下载地址：<a href="https://download.oracle.com/otn-pub/java/jdk/14+36/076bab302c7b4508975440c56f6cc26a/jdk-14_linux-x64_bin.tar.gz" target="_blank" rel="noopener">https://download.oracle.com/otn-pub/java/jdk/14+36/076bab302c7b4508975440c56f6cc26a/jdk-14_linux-x64_bin.tar.gz</a> 下载太慢，尝试使用迅雷等工具，如果链接地址有 auth 字样的参数，请删除</li></ul><p>以下是在 linux 环境中安装, 用 <code>$</code> 来注明</p><pre><code class="shell">// 新建目录$ sudo mkdir /url/local -p soft/java// 将软件包移动到新建的目录$ sudo mv ./jdk-14_linux-x64_bin.tar.gz /url/local/soft/java// 移动到 java 目录下$ cd /url/local/soft/java// 解压$ sudo tar -zxvf jdk-14_linux-x64_bin.tar.gz// `ls` 查看发现，没有jre目录，此时需要手动安装一下$ sudo cd jdk-14/bin &amp;&amp; ./jlink.exe --module-path jmods --add-modules java.desktop --output jre// 设置环境变量$ sudo vim /etc/profile// 在文件末尾添加以下代码</code></pre><pre><code class="shell">// /etc/profileset java environmentJAVA_HOME=/usr/local/soft/java/jdk-14        JRE_HOME=/usr/local/soft/java/jdk-14/jre     CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH</code></pre><pre><code class="shell">// 刷新终端区域，使配置生效。$ sudo source /etc/profile// 测试$ java -version</code></pre><p>打印出 java 版本信息，则说明 JDK 安装成功</p><p><strong>注意，如果你在 <code>wsl</code>，可能需要重启 linux 子系统，简单除暴，重启下电脑</strong></p><h1 id="安装-maven-并配置-阿里源"><a href="#安装-maven-并配置-阿里源" class="headerlink" title="安装 maven 并配置 阿里源"></a>安装 maven 并配置 阿里源</h1><ul><li>官网地址：<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a></li><li>国内加速地址：<a href="http://mirror.bit.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz" target="_blank" rel="noopener">http://mirror.bit.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz</a></li></ul><pre><code class="shell">// 新建目录$ sudo mkdir /url/local/soft/maven // 移动到新建好的目录$ cd /url/local/soft/maven // 下载安装包$ sudo wget http://mirror.bit.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz// 解压$ sudo tar zvxf apache-maven-3.6.3-bin.tar.gz// 测试安装包, 如果可以打印出版本信息，则下载、解压没有问题$ sudo cd apache-maven-3.6.3 &amp;&amp; ./bin/mvn -v </code></pre><pre><code class="shell">// 设置环境变量$ sudo vim /etc/profile// 在文件结尾添加以下配置信息export MAVEN_HOME=/url/local/soft/maven/apache-maven-3.6.3export PATH=$MAVEN_HOME/bin:$PATH// 保存并source profile$ sudo source /ect/profile// 测试环境变量$ mvn -v</code></pre><p>打印出 maven  版本信息，则说明 maven 安装成功<br><strong>注意，如果你在 <code>wsl</code>，可能需要重启 linux 子系统，简单除暴，重启下电脑</strong></p><ul><li>配置国内 阿里 镜像 源，或者是 私有库地址加速</li></ul><pre><code class="shell"> &lt;mirror&gt;      &lt;id&gt;alimaven&lt;/id&gt;      &lt;name&gt;aliyun maven&lt;/name&gt;      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;       &lt;/mirror&gt;</code></pre><p>首先，编辑文件 <code>/url/local/soft/maven/apache-maven-3.6.3/conf/settings.xml</code>，将上述的配置信息添加到 mirrors（镜像）节点。<br>然后，重启 vs code，即可生效。</p><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul><li>java 或者 jdk 安装路径 <code>/usr/local/soft/java/jdk-14</code></li><li>maven 安装路径 <code>/usr/local/soft/maven/apache-maven-3.6.3</code></li></ul><p>可能每个人 安装的 路径 不太相同，除非是按着以上步骤来的，不过不要紧，可以通过<br><code>which mvn</code> 和 <code>which java</code> 分别来查看 当前系统安装的 maven 和 java 的路径<br>比如我查到的路径分别为：</p><ul><li><code>/usr/local/soft/maven/apache-maven-3.6.3/bin/mvn</code></li><li><code>/usr/local/soft/java/jdk-14/bin/java</code></li></ul><p>So easy, too happy !</p><h1 id="安装扩展包"><a href="#安装扩展包" class="headerlink" title="安装扩展包"></a>安装扩展包</h1><ul><li><ol><li>搜索并安装  java Extension Pack </li></ol></li><li><ol start="2"><li>搜索并安装 Spring Boot Extension Pack</li></ol></li><li><ol start="3"><li>重启编辑器</li></ol><p>以上两个扩展已关联java项目开发主要使用的maven、springboot等所需要的扩展。</p></li></ul><h1 id="配置-maven、java-扩展包"><a href="#配置-maven、java-扩展包" class="headerlink" title="配置 maven、java 扩展包"></a>配置 maven、java 扩展包</h1><p>点左下角的设置图标-&gt;设置</p><pre><code class="json">// settings.json{    &quot;java.home&quot;: &quot;/usr/local/soft/java/jdk-14&quot;,    &quot;java.configuration.maven.userSettings&quot;: &quot;/url/local/soft/maven/apache-maven-3.6.3/conf/settings.xml&quot;,    &quot;maven.executable.path&quot;: &quot;/usr/local/soft/maven/apache-maven-3.6.3/bin/mvn&quot;,    &quot;maven.terminal.useJavaHome&quot;: true,    &quot;maven.terminal.customEnv&quot;: [        {            &quot;environmentVariable&quot;: &quot;JAVA_HOME&quot;,            &quot;value&quot;: &quot;/usr/local/soft/java/jdk-14&quot;        }    ]}</code></pre><p>主要的配置信息，如上。</p><h1 id="创建一个-Spring-Boot-项目"><a href="#创建一个-Spring-Boot-项目" class="headerlink" title="创建一个 Spring Boot 项目"></a>创建一个 Spring Boot 项目</h1><blockquote><p>输入Ctrl + Shift + P 打开命令面板，按照以下步骤填写相应内容即可：</p><ol><li>输入Spring，选择maven类型工程</li><li>选择工程的语言：java</li><li>填写工程的Group Id：com.test</li><li>填写工程的ArtifactId：demo</li><li>选择springboot版本：2.0.5</li><li>搜索添加你需要的依赖库，鼠标单击可勾选，这里只添加以下几个：<br>DevTools（代码修改热更新，无需重启）、Web（集成tomcat、SpringMVC）、Lombok（智能&gt; 生成setter、getter、toString等接口，无需手动生成，代码更简介）</li><li>选定依赖库后回车，然后选择一个目录用于初始化工程文件，最后会提示是否打开工程目录，点”open it”，或者自己手动从编辑器左侧的文件-打开文件夹-选定刚才这个目录即可。</li></ol></blockquote><h1 id="配置运行环境"><a href="#配置运行环境" class="headerlink" title="配置运行环境"></a>配置运行环境</h1><p>启动工程之前还需要配置下运行环境，点左边的小虫子图标，然后点上面的下拉箭头，选择添加配置，VS Code会自动为我们创建启动配置，我们只要修改mainClass就好了，配置示例如下：</p><pre><code class="json">{    // 使用 IntelliSense 了解相关属性。     // 悬停以查看现有属性的描述。    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            &quot;type&quot;: &quot;java&quot;,            &quot;name&quot;: &quot;CodeLens (Launch) - DemoApplication&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;mainClass&quot;: &quot;com.example.demo.DemoApplication&quot;,            &quot;projectName&quot;: &quot;demo&quot;        }    ]}</code></pre><p>按F5或者点 DemoApplication.java 的 run 按钮启动，此时在命令行可知tomcat服务已经启动，端口号是8080，访问路径根目录为空。</p><p>在浏览器访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br>提示如下错误：</p><hr><p><strong>Whitelabel Error Page</strong><br>This application has no explicit mapping for /error, so you are seeing this as a fallback.</p><p>Mon Mar 30 19:41:47 CST 2020<br>There was an unexpected error (type=Not Found, status=404).<br>No message available</p><hr><p>这说明我们的服务确实启动可用了，但是访问出这个错误，是因为我们没有定义服务器访问这个根路径对应的应答接口导致的。我们在 demo 包下面新建个 controller 包，然后新建个 HomeController.java 文件，内容如下：</p><pre><code class="java">package com.example.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HomeController {    @RequestMapping(&quot;/&quot;)    public String home(){        return &quot;你好，欢迎使用Visual Studio Code!&quot;;    }}</code></pre><p>此时等待 应用重启，再次访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> </p><hr><p>你好，欢迎使用 Visual Studio Code!</p><hr><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>欢迎使用 *<em>Visual Studio Code *</em>！</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote><p>原文链接：<a href="https://blog.csdn.net/xiaocy66/java/article/details/82875770" target="_blank" rel="noopener">https://blog.csdn.net/xiaocy66/java/article/details/82875770</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> liunx </tag>
            
            <tag> java </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 win 10 环境下 如何打造一套适合的开发环境之前端环境</title>
      <link href="/2020/02/21/66b0ce80-95f9-11ea-926e-6f56d5e2c488/"/>
      <url>/2020/02/21/66b0ce80-95f9-11ea-926e-6f56d5e2c488/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>win10 专业版 </li></ul><blockquote><p>如果安装的是 win10 企业版本呢，由于太纯净了，连<strong>应用商店</strong>都没有，我们需要自己去下载一下<strong>应用商店</strong></p></blockquote><ul><li><p>开启 Linux 子系统服务</p><p>操作 步骤：</p><ol><li>打开 <strong>控制面板</strong></li><li>找到 <strong>程序</strong></li><li>点击 <strong>启用或关闭 Windows 功能</strong></li><li>在差不多倒数的几个，找到 <strong>适用于Linux 的 Windows 子系统</strong> ，<em>打勾</em>，等待安装好后，重启电脑</li></ol></li><li><p>安装 Linux 子系统</p><ol><li>打开 <strong>应用商店</strong>，如果没有登陆，需要实现登录 一下</li><li>搜索 Linux </li><li>选择 <strong>Ubuntu 18.04 LTS</strong> 选择安装，如果下载速度较慢，可以打开<strong>传递优化</strong></li><li>等待下载好后，直接启动就好，此处一般时间比较长，请耐心等待，开启后，设置自己的 <strong>用户名</strong> 和 <strong>密码</strong></li></ol></li><li><p>启动配置 Ubuntu</p><p>这里可以根据自身来配置一些东西，比如替换镜像为国内阿里源，具体的配置还需要，自己去查就好，</p><p>如果要使用 root 权限，直接使用 sudo + commend 就好</p></li></ul><h2 id="安装编辑器"><a href="#安装编辑器" class="headerlink" title="安装编辑器"></a>安装编辑器</h2><p>这里可选择 vscode 为例，因为 vsCode 有现成的插件可以很好的在 wsl 中调试代码、共享文件</p><a id="more"></a><ul><li>下载地址：<a href="https://code.visualstudio.com/docs/?dv=win" target="_blank" rel="noopener">https://code.visualstudio.com/docs/?dv=win</a></li><li>安装插件：</li></ul><ol><li>直接搜索 <code>@idms-vscode-remote.remote-wsl</code> 安装，关于更多 wsl 在 vs 中使用，可参考 <a href="https://aka.ms/vscode-remote/wsl/getting-started" target="_blank" rel="noopener">https://aka.ms/vscode-remote/wsl/getting-started</a></li><li>其他的插件可根据自身去 下载、安装，比如 中文包、主题、图标等</li><li>重启编辑器</li></ol><h2 id="在-ubuntu-中安装-开发环境"><a href="#在-ubuntu-中安装-开发环境" class="headerlink" title="在 ubuntu 中安装 开发环境"></a>在 ubuntu 中安装 开发环境</h2><p>此处以安装 nodejs 为例，打开 vscode 编辑器，按 <code>ctrl</code> + ` 打开终端，此时发现还是 win10 的命令行，我们可以点击左侧边栏的 <strong>远程资源管理器</strong>，进入到 wsl 列表中，选中我们刚刚安装的 ubuntu18.04 ，此时会重新开一个窗口，这时我们在 打开终端，我们会发现已经进入到我们的 Linux 系统了。</p><p>安装 nodejs 所有命令以及操作如下：</p><pre><code class="shell">// 获取最新的node二进制包$ wegt https://npm.taobao.org/mirrors/node/v12.16.1/node-v12.16.1-linux-x64.tar.xz// 解压node包$ tar -xvf  node-v12.16.1-linux-x64.tar.xz// 建立 nodejs 文件夹 并将解压好的移入 nodejs 文件夹$ cd /usr/local/$ sudo mkdir -p soft/nodejs// 不要一味的赋值，看清自己下载的版本$ sudo mv ~/node-v12.16.1-linux-x64/* ./nodejs/// 建立软连接$ sudo ln -s /usr/local/soft/nodejs/bin/node  /usr/local/bin/node$ sudo ln -s /usr/local/soft/nodejs/bin/npm  /usr/local/bin/npm $ sudo ln -s /usr/local/soft/nodejs/bin/npx  /usr/local/bin/npx// 测试安装成功与否,如果打印出版本信息，则安装成功，如果没有，则应细细检查步骤，重复一下$ npm -v //  6.13.4$ node -v // v12.16.1$ npx -v // 6.13.4// 如果在生产服务器上，可以用ftp上传// 注意，如果在生产服务器上安装时，最好是建立一个node的用户，方便管理，由于是本地开发我们就可以随自己喜好了</code></pre><h2 id="测试刚刚搭建好的开发环境"><a href="#测试刚刚搭建好的开发环境" class="headerlink" title="测试刚刚搭建好的开发环境"></a>测试刚刚搭建好的开发环境</h2><p>在 win10 中，新建一个项目文件夹，右键用 vscode 打开，在左下角点击绿色的双对箭头(&gt;&lt;)图标,选择 Reopen Folder in WSL，按 <code>ctrl</code> + ` 进入命令行，如下：</p><pre><code class="she">****@***:/mnt/c/project$ </code></pre><p>由路径可一看出来，我们的工程目录已经自动挂载到Linux系统重量。</p><h2 id="打开-linux-子系统的文件"><a href="#打开-linux-子系统的文件" class="headerlink" title="打开 linux 子系统的文件"></a>打开 linux 子系统的文件</h2><p><code>\\wsl$\Ubuntu-18.04\home\</code></p><p>此时请享受，在linxu环境下，带来的畅快体验，可以避免大量由于Windows的原因导致的坑点。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>请认真反复</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> 前端 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> liunx </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用自己的云服务器搭建内网穿透，免费不限量，主要是速度很给力</title>
      <link href="/2018/09/04/fc6247d0-9679-11ea-8eb3-976c7845fdb4/"/>
      <url>/2018/09/04/fc6247d0-9679-11ea-8eb3-976c7845fdb4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在开发一款基于微信的产品，这里不得不说，<a href="https://github.com/overtrue/wechat" target="_blank" rel="noopener">超哥</a> 的 <a href="https://www.easywechat.com/" target="_blank" rel="noopener">wechatSdk</a> 确实好用，节省了不少时间，但是在本地开发总是会用到内网穿透来实现和微信服务器联调的环节。以前也用户过诸如 <a href="https://natapp.cn" target="_blank" rel="noopener">natapp</a> 类的工具，一个原因是因为，这类工具都是需要费用的，虽然有免费的版本，但是总是会掉线，而且还是限流量。也用过Ngnok，但是如果自己搭建起来比较麻烦，失败率太高了。直接用的话，服务器在国外，在天朝访问你懂的，那是相当的缓慢，一袋烟的功夫过去了，还是个毛都没有，微信接口验证，通过的话，还得看运气。而且每次一个网址只能是用八小时左右，这就需要每次都得到公众号里面重新配置。额……又得等。之前偶然间发现，一个国人开源的神器 <a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a> ，真的是太棒了，这里分下能给大家。具体能实现的功能，文档里面有详细的说明，我就不罗嗦了。给大家<a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">中文文档</a>。接下来给大家分享一下搭建步骤，也是一个备忘，有好东西当然是要分享了。<br>对了，最近开发微信公众平台需要一些测试用户，希望大家帮忙关注一下，不会给您带来困扰的，这里谢谢各位了。</p><a id="more"></a><h1 id="搭建前端准备工作"><a href="#搭建前端准备工作" class="headerlink" title="搭建前端准备工作"></a>搭建前端准备工作</h1><blockquote><ol><li>拥有独立公网IP的云服务器；</li><li>会简单的liunx命令；</li><li>需要一丢丢耐心。</li></ol></blockquote><blockquote><h3 id="这里我演示的环境："><a href="#这里我演示的环境：" class="headerlink" title="这里我演示的环境："></a>这里我演示的环境：</h3></blockquote><ul><li>公网服务器：<strong>系统：</strong>ubuntu16.04  ** ip<strong>：x.x.x.x **开放端口：</strong>7000（绑定frp）  7500（虚拟机） <strong>作用：</strong>用来做内网穿透的服务器</li><li>内网服务器（虚拟机）：<strong>系统：</strong>centos7  ** ip：<strong>192.168.43.133 **开放端口：</strong> 22 <strong>作用：</strong>用来实现通过外网访问，ssh登陆虚拟机 </li><li>内网（win 10_64bit）： 作用：演示  本地通过访问外网实现访问本地服务器</li><li>公网服务器与内网服务器都需要下载frp进行安装，公网服务器（服务端)</li></ul><h1 id="实际操练"><a href="#实际操练" class="headerlink" title="实际操练"></a>实际操练</h1><blockquote><p>1.下载：<code>wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz</code><br>2.解压好：<code>tar -zxvf  frp_0.13.0_linux_amd64.tar.gz</code><br>3.进入解压目录 <code>cd  frp_0.13.0_linux_amd64</code><br>4.这里主要关注4个文件，分别是frpc、frpc.ini和frps、frps.ini，前者两个文件是客户端所关注文件，后者两个文件是服务端所关注两个文件。<br>5.配置服务端（公网服务器）<code>vim ./frps.ini</code>:</p></blockquote><pre><code>[common]bind_port = 7000           #与客户端绑定的进行通信的端口vhost_http_port = 80    #访问客户端web服务自定义的端口号 subdomain_host = test.com # 泛域名解析到 公网IP：x.x.x.xtoken = 123456 #验证客户端</code></pre><p>6.保存然后启动服务<code>./frps -c ./frps.ini</code>，这是前台启动，后台启动命令为<code>nohup ./frps -c ./frps.ini &amp;</code></p><blockquote><p>7.在win10_64bit 中下载 <a href="https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_windows_amd64.zip" target="_blank" rel="noopener">这个</a>。<br>8.配置客户端（内网）<code>vim ./frpc.ini</code>:</p></blockquote><pre><code>[common]server_addr = x.x.x.xserver_port = 7000token = 123456 # 用于验证服务端[web]type = httplocal_ip = 127.0.0.1local_port = 80subdomain = paper # 二级域名 访问时 即: paper.test.com[ssh]type = tcp local_ip = 192.168.43.133# 虚拟机的内网iplocal_port = 22 #虚拟机的ssh端口remote_port = 8085 #在云服务器记得放行此端口,注意这里不需要在服务端指定</code></pre><blockquote><p>9.保存然后执行./frpc -c ./frpc.ini启动，这是前台启动</p></blockquote><blockquote><p>10、具体访问:<br><code>ssh -oPort=8085 shijf@x.x.x.x</code> 相当于在内网使用 <code>ssh  shijf@192.168.43.133</code><br>打开浏览器访问 <code>http://paper.test.com</code></p></blockquote><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>这里内网穿透并不能直接穿透到我们的内网域名,即 <code>local_ip</code><br>设置为 <code>local_ip = paper.test</code> 它还是访问到 默认的 127.0.0.1<br>这里可以 使用 将 <code>paper.test</code> 的端口修改为 <code>81</code>:,<br>那么我们可以在 客户端你这样设置:<code>local_port = 81</code><br>这样当你访问 <code>http://paper.test.com</code> 就可以直接 访问到 内网域名了,记得在 内网服务器也改  <code>http://paper.test.com</code> 的监听端口为 <code>81</code>.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里安利这么久,确实时因为它,真的不错,访问速度快(当然取决于你的云服务器的带宽和内网服务器的配置),如果你也正好在开发微信应用,不如试试吧.</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盼望着，盼望着 let&#39;s encrypt 泛域名野卡证书，终于终于上线了</title>
      <link href="/2018/07/30/a545f2b0-967b-11ea-a177-d1521733a308/"/>
      <url>/2018/07/30/a545f2b0-967b-11ea-a177-d1521733a308/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>首先说下，什么叫泛域名，假如我有一个域名 sharef.top ,那么主域名就是 <a href="https://www.sharef.top" target="_blank" rel="noopener">www.sharef.top</a> , 假如还想做一个网站，域名为<a href="https://f.sharef.top" target="_blank" rel="noopener"> f.sharef.top</a> ,如果要想 访问这两个网站，那么我们得同时将我们的这两个域名A记录解析到服务器的IP，同样，假如我们需要为这两个网站 申请 ssl 证书，那么我们要申请两个，来配置。但是泛域名解析的话，我们只需要将 * .sharef.top 这一条 A 记录解析到我们的服务器就好了，那么不管我们，想要访问a.sharef.xin,还是 b.sharef.top 都会解析到 我们的服务器。同样 泛域名解析 也是一样，我们只需申请一次的  .sharef.top 证书，我们这里的 二级域名都是可以 用这一个 ssl 证书就可以了。</p><a id="more"></a><h1 id="官方参考"><a href="#官方参考" class="headerlink" title="官方参考"></a>官方参考</h1><p>GitHub：<a href="https://github.com/Neilpang/acme.sh" target="_blank" rel="noopener">仓库在这里</a><br>官方中文说明：<a href="https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">中文文档</a><br>DNSAPI：你可能会是不同的DNS服务商，在 <a href="https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md" target="_blank" rel="noopener">这里</a>会查到</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>首先你要有一台公网服务器：这里我以 <strong><em>阿里云</em></strong>的  centos 7 为例演示：<br>需要安装一些必要的软件 ：</p><pre><code>yum update &amp;&amp; yum install curl -y &amp;&amp; yum install cron -y &amp;&amp; yum install socat -y</code></pre><p><strong>以下操作也可以参考官方文档哈</strong></p><h1 id="使用阿里云域名-api-申请Let’s-Encrypt泛域名免费ssl证书"><a href="#使用阿里云域名-api-申请Let’s-Encrypt泛域名免费ssl证书" class="headerlink" title="使用阿里云域名 api 申请Let’s Encrypt泛域名免费ssl证书"></a>使用阿里云域名 api 申请Let’s Encrypt泛域名免费ssl证书</h1><h2 id="下载-acme-sh-并且执行"><a href="#下载-acme-sh-并且执行" class="headerlink" title="下载 acme.sh 并且执行"></a>下载 acme.sh 并且执行</h2><pre><code>curl https://get.acme.sh | sh</code></pre><h2 id="获取阿里云的Access-Key-ID和Access-Key-Secret到环境变量中"><a href="#获取阿里云的Access-Key-ID和Access-Key-Secret到环境变量中" class="headerlink" title="获取阿里云的Access Key ID和Access Key Secret到环境变量中"></a>获取阿里云的Access Key ID和Access Key Secret到环境变量中</h2><p>阿里云的Access Key ID和Access Key Secret可以在下面<a href="https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fak-console.aliyun.com%2F%3Fspm%3D5176.2020520001.0.0.0EJtVx#/accesskey" target="_blank" rel="noopener">这个</a>页面中登录获取<br><img src="https://cdn.learnku.com/uploads/images/201807/30/18751/Fv5i4dMUpl.png?imageView2/2/w/1240/h/0" alt="file"></p><p>执行以下命令，将密钥添加到环境变量中</p><pre><code>export Ali_Key=&quot;你的Access Key ID&quot;export Ali_Secret=&quot;你的 Access Key Secret&quot;</code></pre><p><img src="https://cdn.learnku.com/uploads/images/201807/30/18751/27CcV0W6Si.png?imageView2/2/w/1240/h/0" alt="file"></p><h2 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h2><p>执行以下命令（将domain.com换成自己的域名）：</p><pre><code>~/.acme.sh/acme.sh --issue --dns dns_ali -d domain.com -d *.domain.com</code></pre><p><strong>注意：第一个 -d 后不可直接写通配符域名*.domain.com，一定要写个单域名，第二个 -d 后面可以写泛域名。<br>否则可能会出现签发的证书无法被信任的情况。</strong></p><p><img src="https://cdn.learnku.com/uploads/images/201807/30/18751/XcZOssYu4p.png?imageView2/2/w/1240/h/0" alt="file"></p><h3 id="之后把这些证书下载下来就好了，所有文件在-acme-sh-你的域名-目录下面就可以了"><a href="#之后把这些证书下载下来就好了，所有文件在-acme-sh-你的域名-目录下面就可以了" class="headerlink" title="之后把这些证书下载下来就好了，所有文件在.acme.sh/你的域名 目录下面就可以了"></a>之后把这些证书下载下来就好了，所有文件在.acme.sh/你的域名 目录下面就可以了</h3><p>配置 ssl 的问题就 自行 搜索教程吧，证书都有啦，还怕搞不成？</p><h1 id="重重之中，记得放行服务器-443端口"><a href="#重重之中，记得放行服务器-443端口" class="headerlink" title="重重之中，记得放行服务器 443端口"></a>重重之中，记得放行服务器 443端口</h1><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li>作者：Noisky  <a href="https://ffis.me/experience/1261.html" target="_blank" rel="noopener">let’s encrypt泛域名野卡证书配置笔记</a></li><li>作者：bboysoul <a href="https://yq.aliyun.com/articles/541843" target="_blank" rel="noopener">使用阿里云域名api申请Let’s Encrypt泛域名免费ssl证书</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
